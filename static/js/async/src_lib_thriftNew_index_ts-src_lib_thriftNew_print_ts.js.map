{"version":3,"file":"static/js/async/src_lib_thriftNew_index_ts-src_lib_thriftNew_print_ts.js","sources":["/Users/didi/Desktop/github/thrift-to-ts-online/src/lib/thriftNew/@creditkarma/thrift-parser/debugger.ts","/Users/didi/Desktop/github/thrift-to-ts-online/src/lib/thriftNew/@creditkarma/thrift-parser/factory.ts","/Users/didi/Desktop/github/thrift-to-ts-online/src/lib/thriftNew/@creditkarma/thrift-parser/index.ts","/Users/didi/Desktop/github/thrift-to-ts-online/src/lib/thriftNew/@creditkarma/thrift-parser/keywords.ts","/Users/didi/Desktop/github/thrift-to-ts-online/src/lib/thriftNew/@creditkarma/thrift-parser/organizer.ts","/Users/didi/Desktop/github/thrift-to-ts-online/src/lib/thriftNew/@creditkarma/thrift-parser/parser.ts","/Users/didi/Desktop/github/thrift-to-ts-online/src/lib/thriftNew/@creditkarma/thrift-parser/scanner.ts","/Users/didi/Desktop/github/thrift-to-ts-online/src/lib/thriftNew/@creditkarma/thrift-parser/types.ts","/Users/didi/Desktop/github/thrift-to-ts-online/src/lib/thriftNew/handleComments.ts","/Users/didi/Desktop/github/thrift-to-ts-online/src/lib/thriftNew/index.ts","/Users/didi/Desktop/github/thrift-to-ts-online/src/lib/thriftNew/print.ts","/Users/didi/Desktop/github/thrift-to-ts-online/src/lib/tools/utils.ts"],"sourcesContent":["import { ErrorType, TextLocation, ThriftError } from './types'\n\nexport type ErrorReporter = (err: ThriftError) => void\n\n\nexport interface Debugger {\n    report: ErrorReporter\n    hasError(): boolean\n    getErrors(): Array<ThriftError>\n    getFormattedErrors(): Array<FormattedError>\n    print(): void\n}\n\nexport interface FormattedError {\n    sourceLine: string\n    locIndicator: string\n    line: number\n    column: number\n    message: string\n    type: ErrorType\n}\n\nexport function noopReporter(err: ThriftError): void {\n    throw new Error(`${err.type}: Line: ${err.loc.start.line}: ${err.message}`)\n}\n\nfunction padLeft(num: number, str: string): string {\n    while (str.length < num) {\n        str = ' ' + str\n    }\n    return str\n}\n\nfunction indicatorForLocaction(loc: TextLocation): string {\n    const indicator: string = padLeft(loc.start.column, '^')\n    return indicator\n}\n\nfunction padStart(length: number, str: string): string {\n    let paddedStr: string = str\n    while (length--) {\n        paddedStr = ' ' + paddedStr\n    }\n\n    return paddedStr\n}\n\nfunction errorType(type: ErrorType): string {\n    switch (type) {\n        case ErrorType.ParseError:\n            return 'Parse Error:'\n\n        case ErrorType.ScanError:\n            return 'Scan Error:'\n    }\n}\n\nexport function createDebugger(source: string): Debugger {\n    // const sourceLines: Array<string> = source.split(os.EOL)\n    const sourceLines: Array<string> = source.split('\\n')\n    const formattedErrors: Array<FormattedError> = []\n    const rawErrors: Array<ThriftError> = []\n\n    function getSourceLine(lineNumber: number): string {\n        return sourceLines[lineNumber - 1]\n    }\n\n    function formatError(err: ThriftError): FormattedError {\n        return {\n            sourceLine: getSourceLine(err.loc.start.line),\n            locIndicator: indicatorForLocaction(err.loc),\n            line: err.loc.start.line,\n            column: err.loc.start.column,\n            message: err.message,\n            type: err.type,\n        }\n    }\n\n    return {\n        hasError(): boolean {\n            return formattedErrors.length > 0\n        },\n\n        getErrors(): Array<ThriftError> {\n            return rawErrors\n        },\n\n        getFormattedErrors(): Array<FormattedError> {\n            return formattedErrors\n        },\n\n        report(err: ThriftError): void {\n            const formattedError: FormattedError = formatError(err)\n            formattedErrors.push(formattedError)\n            rawErrors.push(err)\n        },\n\n        print(): void {\n            console.log(\n                `Parse Failure: ${formattedErrors.length} errors found:`,\n            )\n            console.log()\n            formattedErrors.forEach(\n                (err: FormattedError): void => {\n                    const prefix: string = `${err.line} | `\n\n                    console.log()\n                    console.log(`${errorType(err.type)}\\n`)\n                    console.log(`Message: ${err.message}`)\n                    console.log()\n                    console.log(`${prefix}${err.sourceLine}`)\n                    console.log(padStart(prefix.length, err.locIndicator))\n                    console.log()\n                },\n            )\n        },\n    }\n}\n","import {\n    Annotations,\n    BaseType,\n    BooleanLiteral,\n    Comment,\n    ConstList,\n    ConstMap,\n    ConstValue,\n    DoubleConstant,\n    ErrorType,\n    ExponentialLiteral,\n    FieldDefinition,\n    FieldID,\n    FieldRequired,\n    FieldType,\n    FloatLiteral,\n    FunctionType,\n    HexLiteral,\n    Identifier,\n    IntConstant,\n    IntegerLiteral,\n    KeywordType,\n    ListType,\n    MapType,\n    ParseError,\n    PropertyAssignment,\n    ScanError,\n    SetType,\n    StringLiteral,\n    StructDefinition,\n    SyntaxType,\n    TextLocation,\n    TextPosition,\n    Token,\n} from './types'\n\nexport function createParseError(\n    message: string,\n    loc: TextLocation,\n): ParseError {\n    return {\n        type: ErrorType.ParseError,\n        message,\n        loc,\n    }\n}\n\nexport function createScanError(message: string, loc: TextLocation): ScanError {\n    return {\n        type: ErrorType.ScanError,\n        message,\n        loc,\n    }\n}\n\nexport function createTextLocation(\n    start: TextPosition,\n    end: TextPosition,\n): TextLocation {\n    return { start, end }\n}\n\nexport function createTextPosition(\n    line: number,\n    column: number,\n    index: number,\n): TextPosition {\n    return { line, column, index }\n}\n\nexport function createToken(\n    type: SyntaxType,\n    text: string,\n    loc: TextLocation,\n): Token {\n    return { type, text, loc }\n}\n\nexport function createIdentifier(\n    value: string,\n    loc: TextLocation,\n    annotations?: Annotations,\n): Identifier {\n    return { type: SyntaxType.Identifier, value, loc, annotations }\n}\n\nexport function creataePropertyAssignment(\n    name: ConstValue,\n    initializer: ConstValue,\n    loc: TextLocation,\n): PropertyAssignment {\n    return {\n        type: SyntaxType.PropertyAssignment,\n        name,\n        initializer,\n        loc,\n    }\n}\n\nexport function createFieldDefinition(\n    name: Identifier,\n    fieldID: FieldID,\n    requiredness: FieldRequired,\n    fieldType: FunctionType,\n    loc: TextLocation,\n    defaultValue: ConstValue | null = null,\n    annotations?: Annotations,\n    comments: Array<Comment> = [],\n): FieldDefinition {\n    return {\n        type: SyntaxType.FieldDefinition,\n        name,\n        fieldID,\n        requiredness,\n        fieldType,\n        defaultValue,\n        annotations,\n        comments,\n        loc,\n    }\n}\n\nexport function createFieldID(value: number, loc: TextLocation): FieldID {\n    return {\n        type: SyntaxType.FieldID,\n        value,\n        loc,\n    }\n}\n\nexport function createStructDefinition(\n    name: Identifier,\n    fields: Array<FieldDefinition>,\n    loc: TextLocation,\n    comments: Array<Comment> = [],\n): StructDefinition {\n    return {\n        type: SyntaxType.StructDefinition,\n        name,\n        fields,\n        comments,\n        loc,\n    }\n}\n\nexport function createStringLiteral(\n    value: string,\n    loc: TextLocation,\n): StringLiteral {\n    return {\n        type: SyntaxType.StringLiteral,\n        value,\n        loc,\n    }\n}\n\nexport function createIntegerLiteral(\n    value: string,\n    loc: TextLocation,\n): IntegerLiteral {\n    return { type: SyntaxType.IntegerLiteral, value, loc }\n}\n\nexport function createHexLiteral(value: string, loc: TextLocation): HexLiteral {\n    return { type: SyntaxType.HexLiteral, value, loc }\n}\n\nexport function createFloatLiteral(\n    value: string,\n    loc: TextLocation,\n): FloatLiteral {\n    return { type: SyntaxType.FloatLiteral, value, loc }\n}\n\nexport function createExponentialLiteral(\n    value: string,\n    loc: TextLocation,\n): ExponentialLiteral {\n    return { type: SyntaxType.ExponentialLiteral, value, loc }\n}\n\nexport function createIntConstant(\n    value: IntegerLiteral | HexLiteral,\n    loc: TextLocation,\n): IntConstant {\n    return { type: SyntaxType.IntConstant, value, loc }\n}\n\nexport function createDoubleConstant(\n    value: FloatLiteral | ExponentialLiteral,\n    loc: TextLocation,\n): DoubleConstant {\n    return { type: SyntaxType.DoubleConstant, value, loc }\n}\n\nexport function createBooleanLiteral(\n    value: boolean,\n    loc: TextLocation,\n): BooleanLiteral {\n    return { type: SyntaxType.BooleanLiteral, value, loc }\n}\n\nexport function createKeywordFieldType(\n    type: KeywordType,\n    loc: TextLocation,\n    annotations?: Annotations,\n): BaseType {\n    return { type, loc, annotations }\n}\n\nexport function createMapFieldType(\n    keyType: FieldType,\n    valueType: FieldType,\n    loc: TextLocation,\n    annotations?: Annotations,\n): MapType {\n    return {\n        type: SyntaxType.MapType,\n        keyType,\n        valueType,\n        loc,\n        annotations,\n    }\n}\n\nexport function createSetFieldType(\n    valueType: FieldType,\n    loc: TextLocation,\n    annotations?: Annotations,\n): SetType {\n    return {\n        type: SyntaxType.SetType,\n        valueType,\n        loc,\n        annotations,\n    }\n}\n\nexport function createListFieldType(\n    valueType: FieldType,\n    loc: TextLocation,\n    annotations?: Annotations,\n): ListType {\n    return {\n        type: SyntaxType.ListType,\n        valueType,\n        loc,\n        annotations,\n    }\n}\n\nexport function createConstMap(\n    properties: Array<PropertyAssignment>,\n    loc: TextLocation,\n): ConstMap {\n    return {\n        type: SyntaxType.ConstMap,\n        properties,\n        loc,\n    }\n}\n\nexport function createConstList(\n    elements: Array<ConstValue>,\n    loc: TextLocation,\n): ConstList {\n    return {\n        type: SyntaxType.ConstList,\n        elements,\n        loc,\n    }\n}\n","// import * as fs from \"node:fs\";\n// import * as path from \"path\";\nimport { createDebugger, Debugger } from \"./debugger\";\nimport { organize } from \"./organizer\";\nimport { createParser, Parser } from \"./parser\";\nimport { createScanner, Scanner } from \"./scanner\";\nimport {\n  ErrorType,\n  SyntaxType,\n  ThriftDocument,\n  ThriftError,\n  ThriftErrors,\n  Token,\n} from \"./types\";\n\nexport * from \"./types\";\nexport * from \"./factory\";\nexport { createScanner } from \"./scanner\";\nexport { createParser } from \"./parser\";\n\nexport interface ParseOptions {\n  fastFail: boolean;\n  rootDir: string;\n  outDir: string;\n  files: Array<string>;\n  organize: boolean;\n  reservedWord?: \"error\" | \"escape\";\n}\n\nexport const defaultOptions: ParseOptions = {\n  fastFail: false,\n  rootDir: \".\",\n  outDir: \".\",\n  files: [],\n  organize: true,\n  reservedWord: \"error\",\n};\n\n// export function parseFiles(\n//   options: Partial<ParseOptions> = {}\n// ): Array<ThriftDocument | ThriftErrors> {\n//   const mergedOptions: ParseOptions = { ...defaultOptions, ...options };\n//   return mergedOptions.files.map(\n//     (file: string): ThriftDocument | ThriftErrors => {\n//       const filePath: string = path.resolve(\n//         process.cwd(),\n//         mergedOptions.rootDir,\n//         file\n//       );\n//       const content: string = fs.readFileSync(filePath, \"utf-8\");\n//       return parse(content, mergedOptions);\n//     }\n//   );\n// }\n\nexport function parse(\n  source: string,\n  options: Partial<ParseOptions> = {}\n): ThriftDocument | ThriftErrors {\n  // HACK: 末尾加上一个不存在的const来获取末尾的注释\n  source += \"\\nconst i32 liuqi=1995\";\n  const mergedOptions: ParseOptions = { ...defaultOptions, ...options };\n  const debug: Debugger = createDebugger(source);\n  const scanner: Scanner = createScanner(source, handleError);\n  const tokens: Array<Token> = scanner.scan();\n\n  const parser: Parser = createParser(tokens, handleError, {\n    reservedWord: options.reservedWord,\n  });\n  const intermediate: ThriftDocument = parser.parse();\n  const thrift: ThriftDocument = mergedOptions.organize\n    ? organize(intermediate)\n    : intermediate;\n\n  /**\n   * This is a safe handler for errors that allows the parser and scanner to recover to a\n   * reasonable state after an error and continue with the parse. If an error occurs we will\n   * not return any output, but using this allows us to catch more errors and report them to\n   * the user at once instead of the work flow of find error -> fix error, find error -> fix error.\n   *\n   * @param err\n   */\n  function handleError(err: ThriftError): void {\n    debug.report(err);\n    if (mergedOptions.fastFail) {\n      debug.print();\n      throw new Error(err.message);\n    } else {\n      switch (err.type) {\n        case ErrorType.ParseError:\n          parser.synchronize();\n          break;\n\n        case ErrorType.ScanError:\n          scanner.syncronize();\n          break;\n      }\n    }\n  }\n\n  if (debug.hasError()) {\n    debug.print();\n    return {\n      type: SyntaxType.ThriftErrors,\n      errors: debug.getErrors(),\n    };\n  } else {\n    return thrift;\n  }\n}\n","import { SyntaxType } from './types'\n\nexport interface KeywordMap {\n    [name: string]: SyntaxType\n}\n\nexport const KEYWORDS: KeywordMap = {\n    namespace: SyntaxType.NamespaceKeyword,\n    include: SyntaxType.IncludeKeyword,\n    cpp_include: SyntaxType.CppIncludeKeyword,\n    const: SyntaxType.ConstKeyword,\n    struct: SyntaxType.StructKeyword,\n    service: SyntaxType.ServiceKeyword,\n    extends: SyntaxType.ExtendsKeyword,\n    throws: SyntaxType.ThrowsKeyword,\n    typedef: SyntaxType.TypedefKeyword,\n    union: SyntaxType.UnionKeyword,\n    enum: SyntaxType.EnumKeyword,\n    senum: SyntaxType.SenumKeyword,\n    list: SyntaxType.ListKeyword,\n    set: SyntaxType.SetKeyword,\n    map: SyntaxType.MapKeyword,\n    double: SyntaxType.DoubleKeyword,\n    i8: SyntaxType.I8Keyword,\n    i16: SyntaxType.I16Keyword,\n    i32: SyntaxType.I32Keyword,\n    i64: SyntaxType.I64Keyword,\n    int8: SyntaxType.Int8Keyword,\n    int16: SyntaxType.Int16Keyword,\n    int32: SyntaxType.Int32Keyword,\n    int64: SyntaxType.Int64Keyword,\n    exception: SyntaxType.ExceptionKeyword,\n    binary: SyntaxType.BinaryKeyword,\n    bool: SyntaxType.BoolKeyword,\n    byte: SyntaxType.ByteKeyword,\n    required: SyntaxType.RequiredKeyword,\n    optional: SyntaxType.OptionalKeyword,\n    string: SyntaxType.StringKeyword,\n    true: SyntaxType.TrueKeyword,\n    false: SyntaxType.FalseKeyword,\n    void: SyntaxType.VoidKeyword,\n    oneway: SyntaxType.OnewayKeyword,\n}\n\n\nexport const RESERVEDWORDS = [\n    'break',\n    'case',\n    'catch',\n    'class',\n    'const',\n    'continue',\n    'debugger',\n    'default',\n    'delete',\n    'do',\n    'else',\n    'enum',\n    'export',\n    'extends',\n    'false',\n    'finally',\n    'for',\n    'function',\n    'if',\n    'import',\n    'in',\n    'instanceof',\n    'new',\n    'null',\n    'return',\n    'super',\n    'switch',\n    'this',\n    'throw',\n    'true',\n    'try',\n    'typeof',\n    'var',\n    'void',\n    'while',\n    'with',\n];\n","import {\n    ConstDefinition,\n    EnumDefinition,\n    ExceptionDefinition,\n    IncludeDefinition,\n    NamespaceDefinition,\n    ServiceDefinition,\n    StructDefinition,\n    SyntaxType,\n    ThriftDocument,\n    TypedefDefinition,\n    UnionDefinition,\n} from './types'\n\nexport function organize(raw: ThriftDocument): ThriftDocument {\n    const namespaces: Array<NamespaceDefinition> = []\n    const includes: Array<IncludeDefinition> = []\n    const constants: Array<ConstDefinition> = []\n    const enums: Array<EnumDefinition> = []\n    const typedefs: Array<TypedefDefinition> = []\n    const structs: Array<StructDefinition> = []\n    const unions: Array<UnionDefinition> = []\n    const exceptions: Array<ExceptionDefinition> = []\n    const services: Array<ServiceDefinition> = []\n\n    for (const next of raw.body) {\n        switch (next.type) {\n            case SyntaxType.NamespaceDefinition:\n                namespaces.push(next)\n                break\n\n            case SyntaxType.IncludeDefinition:\n                includes.push(next)\n                break\n\n            case SyntaxType.CppIncludeDefinition:\n                // We're not generating C++\n                break\n\n            case SyntaxType.ConstDefinition:\n                constants.push(next)\n                break\n\n            case SyntaxType.EnumDefinition:\n                enums.push(next)\n                break\n\n            case SyntaxType.StructDefinition:\n                structs.push(next)\n                break\n\n            case SyntaxType.UnionDefinition:\n                unions.push(next)\n                break\n\n            case SyntaxType.ExceptionDefinition:\n                exceptions.push(next)\n                break\n\n            case SyntaxType.TypedefDefinition:\n                typedefs.push(next)\n                break\n\n            case SyntaxType.ServiceDefinition:\n                services.push(next)\n                break\n\n            default:\n                const msg: never = next\n                throw new Error(`Unexpected statement type found: ${msg}`)\n        }\n    }\n\n    return {\n        type: SyntaxType.ThriftDocument,\n        body: [\n            ...namespaces,\n            ...includes,\n            ...enums,\n            ...typedefs,\n            ...constants,\n            ...structs,\n            ...unions,\n            ...exceptions,\n            ...services,\n        ],\n        tokens: raw.tokens,\n    }\n}\n","/* eslint-disable */\nimport {\n  Annotation,\n  Annotations,\n  Comment,\n  ConstDefinition,\n  ConstList,\n  ConstMap,\n  ConstValue,\n  DoubleConstant,\n  EnumDefinition,\n  EnumMember,\n  ExceptionDefinition,\n  FieldDefinition,\n  FieldID,\n  FieldRequired,\n  FieldType,\n  FunctionDefinition,\n  FunctionType,\n  Identifier,\n  IncludeDefinition,\n  IntConstant,\n  ListType,\n  MapType,\n  NamespaceDefinition,\n  ParametersDefinition,\n  PropertyAssignment,\n  ServiceDefinition,\n  SetType,\n  StructDefinition,\n  StructLike,\n  SyntaxType,\n  TextLocation,\n  ThriftDocument,\n  ThriftStatement,\n  ThrowsDefinition,\n  Token,\n  TypedefDefinition,\n  UnionDefinition,\n} from \"./types\";\n\nimport {\n  creataePropertyAssignment,\n  createBooleanLiteral,\n  createConstList,\n  createConstMap,\n  createDoubleConstant,\n  createExponentialLiteral,\n  createFieldID,\n  createFloatLiteral,\n  createHexLiteral,\n  createIdentifier,\n  createIntConstant,\n  createIntegerLiteral,\n  createKeywordFieldType,\n  createMapFieldType,\n  createParseError,\n  createStringLiteral,\n  createTextLocation,\n} from \"./factory\";\n\nimport { ErrorReporter, noopReporter } from \"./debugger\";\nimport { RESERVEDWORDS } from \"./keywords\";\n\nexport interface Parser {\n  parse(): ThriftDocument;\n  synchronize(): void;\n}\n\nfunction isStatementBeginning(token: Token): boolean {\n  switch (token.type) {\n    case SyntaxType.NamespaceKeyword:\n    case SyntaxType.IncludeKeyword:\n    case SyntaxType.ConstKeyword:\n    case SyntaxType.StructKeyword:\n    case SyntaxType.UnionKeyword:\n    case SyntaxType.ExceptionKeyword:\n    case SyntaxType.ServiceKeyword:\n    case SyntaxType.TypedefKeyword:\n    case SyntaxType.EnumKeyword:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass ParseError extends Error {\n  public message: string;\n  public loc: TextLocation;\n  constructor(msg: string, loc: TextLocation) {\n    super(msg);\n    this.message = msg;\n    this.loc = loc;\n  }\n}\n\nexport function createParser(\n  tokens: Array<Token>,\n  report: ErrorReporter = noopReporter,\n  options?: {\n    reservedWord?: \"error\" | \"escape\";\n  }\n): Parser {\n  let comments: Array<Comment> = [];\n  let currentIndex: number = 0;\n\n  // PUBLIC\n  function parse(): ThriftDocument {\n    const thrift: ThriftDocument = {\n      type: SyntaxType.ThriftDocument,\n      body: [],\n    };\n\n    while (!isAtEnd()) {\n      try {\n        const statement: ThriftStatement | null = parseStatement();\n        if (statement !== null) {\n          thrift.body.push(statement);\n        }\n      } catch (e: any) {\n        report(createParseError(e.message, e.loc));\n      }\n    }\n\n    return thrift;\n  }\n\n  // Finds the beginning of the next statement so we can continue parse after error.\n  function synchronize(): void {\n    while (!isAtEnd() && !isStatementBeginning(currentToken())) {\n      advance();\n    }\n  }\n\n  function parseStatement(): ThriftStatement | null {\n    const next: Token = currentToken();\n\n    // All Thrift statements must start with one of these types\n    switch (next.type) {\n      case SyntaxType.NamespaceKeyword:\n        return parseNamespace();\n\n      case SyntaxType.IncludeKeyword:\n        return parseInclude();\n\n      case SyntaxType.ConstKeyword:\n        return parseConst();\n\n      case SyntaxType.StructKeyword:\n        return parseStruct();\n\n      case SyntaxType.UnionKeyword:\n        return parseUnion();\n\n      case SyntaxType.ExceptionKeyword:\n        return parseException();\n\n      case SyntaxType.ServiceKeyword:\n        return parseService();\n\n      case SyntaxType.TypedefKeyword:\n        return parseTypedef();\n\n      case SyntaxType.EnumKeyword:\n        return parseEnum();\n\n      case SyntaxType.CommentBlock:\n      case SyntaxType.CommentLine:\n        consumeComments();\n        return null;\n\n      default:\n        throw reportError(`Invalid start to Thrift statement ${next.text}`);\n    }\n  }\n\n  // IncludeDefinition → 'include' StringLiteral\n  function parseInclude(): IncludeDefinition {\n    const _keywordToken: Token | null = consume(SyntaxType.IncludeKeyword);\n    const keywordToken = requireValue(\n      _keywordToken,\n      `'indcluded' keyword expected`\n    );\n    const _pathToken: Token | null = consume(SyntaxType.StringLiteral);\n    const pathToken = requireValue(\n      _pathToken,\n      `Include statement must include a path as string literal`\n    );\n\n    return {\n      type: SyntaxType.IncludeDefinition,\n      path: createStringLiteral(pathToken.text, pathToken.loc),\n      comments: getComments(),\n      loc: createTextLocation(keywordToken.loc.start, pathToken.loc.end),\n    };\n  }\n\n  // ServiceDefinition → 'service' Identifier ( 'extends' Identifier )? '{' Function* '} Annotations?'\n  function parseService(): ServiceDefinition {\n    const leadingComments: Array<Comment> = getComments();\n    const _keywordToken: Token | null = consume(SyntaxType.ServiceKeyword);\n    const keywordToken: Token = requireValue(\n      _keywordToken,\n      `Unable to find service keyword for service`\n    );\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Unable to find identifier for service`\n    );\n\n    const extendsId: Identifier | null = parseExtends();\n    const _openBrace: Token | null = consume(SyntaxType.LeftBraceToken);\n    const openBrace = requireValue(_openBrace, `Expected opening curly brace`);\n\n    const functions: Array<FunctionDefinition> = parseFunctions();\n    const _closeBrace: Token | null = consume(SyntaxType.RightBraceToken);\n    const closeBrace = requireValue(\n      _closeBrace,\n      `Expected closing curly brace`\n    );\n\n    const annotations: Annotations | undefined = parseAnnotations();\n\n    const location: TextLocation = createTextLocation(\n      keywordToken.loc.start,\n      closeBrace.loc.end\n    );\n\n    return {\n      type: SyntaxType.ServiceDefinition,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      extends: extendsId,\n      functions,\n      annotations,\n      comments: leadingComments,\n      loc: location,\n    };\n  }\n\n  function parseExtends(): Identifier | null {\n    if (checkText(\"extends\")) {\n      const _keywordToken: Token | null = consume(SyntaxType.ExtendsKeyword);\n      const keywordToken = requireValue(\n        _keywordToken,\n        `'extends keyword expected`\n      );\n      const _nameToken: Token | null = consume(SyntaxType.Identifier);\n      const nameToken = requireValue(\n        _nameToken,\n        `Identifier expected after 'extends' keyword`\n      );\n\n      return createIdentifier(\n        nameToken.text,\n        createTextLocation(keywordToken.loc.start, nameToken.loc.end)\n      );\n    } else {\n      return null;\n    }\n  }\n\n  function parseFunctions(): Array<FunctionDefinition> {\n    const functions: Array<FunctionDefinition> = [];\n\n    while (!check(SyntaxType.RightBraceToken)) {\n      if (check(SyntaxType.CommentBlock, SyntaxType.CommentLine)) {\n        advance();\n      } else {\n        functions.push(parseFunction());\n\n        if (isStatementBeginning(currentToken())) {\n          throw reportError(\n            `Closing curly brace expected, but new statement found`\n          );\n        } else if (check(SyntaxType.EOF)) {\n          throw reportError(\n            `Closing curly brace expected but reached end of file`\n          );\n        }\n      }\n    }\n\n    return functions;\n  }\n\n  // Function → 'oneway'? FunctionType Identifier '(' Field* ')' Throws? Annotations? ListSeparator?\n  function parseFunction(): FunctionDefinition {\n    const leadingComments: Array<Comment> = getComments();\n    const onewayToken: Token | null = consume(SyntaxType.OnewayKeyword);\n    const returnType: FunctionType = parseFunctionType();\n\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Unable to find function identifier`\n    );\n\n    const params: ParametersDefinition = parseParameterFields();\n\n    const throws: ThrowsDefinition | null = parseThrows();\n\n    const annotations: Annotations | undefined = parseAnnotations();\n\n    const listSeparator: Token | null = readListSeparator();\n    const endLoc: TextLocation =\n      listSeparator !== null\n        ? listSeparator.loc\n        : throws !== null\n          ? throws.loc\n          : params.loc;\n\n    return {\n      type: SyntaxType.FunctionDefinition,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      returnType,\n      fields: params.fields,\n      throws: throws !== null ? throws.fields : [],\n      annotations,\n      comments: leadingComments,\n      oneway: onewayToken !== null,\n      modifiers: onewayToken !== null ? [onewayToken] : [],\n      loc: {\n        start: returnType.loc.start,\n        end: endLoc.end,\n      },\n    };\n  }\n\n  function parseParameterFields(): ParametersDefinition {\n    const fields: Array<FieldDefinition> = [];\n    const _openParen: Token | null = consume(SyntaxType.LeftParenToken);\n    const openParen: Token = requireValue(\n      _openParen,\n      `Opening paren expected to start list of fields`\n    );\n\n    while (!check(SyntaxType.RightParenToken)) {\n      readListSeparator();\n      fields.push(parseField());\n\n      if (isStatementBeginning(currentToken())) {\n        throw reportError(\n          `Closing paren ')' expected, but new statement found`\n        );\n      } else if (check(SyntaxType.EOF)) {\n        throw reportError(`Closing paren ')' expected but reached end of file`);\n      }\n    }\n\n    const _closeParen: Token | null = consume(SyntaxType.RightParenToken);\n    const closeParen: Token = requireValue(\n      _closeParen,\n      `Closing paren expected to end list of fields`\n    );\n\n    return {\n      type: SyntaxType.ParametersDefinition,\n      fields,\n      loc: {\n        start: openParen.loc.start,\n        end: closeParen.loc.end,\n      },\n    };\n  }\n\n  // Throws → 'throws' '(' Field* ')'\n  function parseThrows(): ThrowsDefinition | null {\n    if (check(SyntaxType.ThrowsKeyword)) {\n      const _keywordToken: Token | null = consume(SyntaxType.ThrowsKeyword);\n      const keywordToken: Token = requireValue(\n        _keywordToken,\n        `'throws' keyword expected`\n      );\n      const params: ParametersDefinition = parseParameterFields();\n\n      return {\n        type: SyntaxType.ThrowsDefinition,\n        fields: params.fields,\n        loc: {\n          start: keywordToken.loc.start,\n          end: params.loc.end,\n        },\n      };\n    }\n\n    return null;\n  }\n\n  // Namespace → 'namespace' ( NamespaceScope Identifier )\n  function parseNamespace(): NamespaceDefinition {\n    const _keywordToken: Token | null = consume(SyntaxType.NamespaceKeyword);\n    const keywordToken: Token = requireValue(\n      _keywordToken,\n      `'namespace' keyword expected`\n    );\n    const _scopeToken: Token | null = consume(SyntaxType.Identifier);\n    const scopeToken: Token = requireValue(\n      _scopeToken,\n      `Unable to find scope identifier for namespace`\n    );\n\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n\n    if (_nameToken && options?.reservedWord === \"escape\") {\n      const nameTokenText = escapeReservedWordForIdentifier(_nameToken.text);\n      _nameToken.text = nameTokenText;\n    }\n\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Unable to find name identifier for namespace`\n    );\n\n    return {\n      type: SyntaxType.NamespaceDefinition,\n      scope: createIdentifier(scopeToken.text, scopeToken.loc),\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      comments: getComments(),\n      loc: createTextLocation(keywordToken.loc.start, nameToken.loc.end),\n    };\n  }\n\n  // ConstDefinition → 'const' FieldType Identifier '=' ConstValue Annotations? ListSeparator?\n  function parseConst(): ConstDefinition {\n    const leadingComments: Array<Comment> = getComments();\n    const _keywordToken: Token | null = consume(SyntaxType.ConstKeyword);\n    const keywordToken: Token = requireValue(\n      _keywordToken,\n      `'const' keyword expected`\n    );\n    const fieldType: FieldType = parseFieldType();\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Const definition must have a name`\n    );\n\n    const _initializer: ConstValue | null = parseValueAssignment();\n    const initializer: ConstValue = requireValue(\n      _initializer,\n      `Const must be initialized to a value`\n    );\n\n    const annotations: Annotations | undefined = parseAnnotations();\n    readListSeparator();\n\n    return {\n      type: SyntaxType.ConstDefinition,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      fieldType,\n      initializer,\n      annotations,\n      comments: leadingComments,\n      loc: {\n        start: keywordToken.loc.start,\n        end: initializer.loc.end,\n      },\n    };\n  }\n\n  function parseValueAssignment(): ConstValue | null {\n    if (check(SyntaxType.EqualToken)) {\n      advance();\n      return parseValue();\n    }\n\n    return null;\n  }\n\n  // Annotations → '(' Annotation* ')'\n  function parseAnnotations(): Annotations | undefined {\n    if (check(SyntaxType.LeftParenToken)) {\n      const annotations: Array<Annotation> = [];\n      const startToken = advance();\n      while (!check(SyntaxType.RightParenToken)) {\n        annotations.push(parseAnnotation());\n      }\n      const endToken = advance();\n      return {\n        annotations,\n        type: SyntaxType.Annotations,\n        loc: createTextLocation(startToken.loc.start, endToken.loc.end),\n      };\n    }\n\n    return undefined;\n  }\n\n  // Annotation → Identifier ('=' StringLiteral)? ListSeparator?\n  function parseAnnotation(): Annotation {\n    const nameToken: Token = requireValue(\n      consume(SyntaxType.Identifier),\n      `Annotation must have a name`\n    );\n    let valueToken: Token | undefined;\n    if (check(SyntaxType.EqualToken)) {\n      advance();\n      valueToken = requireValue(\n        consume(SyntaxType.StringLiteral),\n        `Annotation must have a value`\n      );\n    }\n\n    readListSeparator();\n\n    return {\n      type: SyntaxType.Annotation,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      value: valueToken\n        ? createStringLiteral(valueToken.text, valueToken.loc)\n        : undefined,\n      loc: createTextLocation(\n        nameToken.loc.start,\n        (valueToken || nameToken).loc.end\n      ),\n    };\n  }\n\n  // TypedefDefinition → 'typedef' FieldType Identifier\n  function parseTypedef(): TypedefDefinition {\n    const _keywordToken: Token | null = consume(SyntaxType.TypedefKeyword);\n    const keywordToken: Token = requireValue(\n      _keywordToken,\n      `'typedef' keyword expected`\n    );\n    const type: FieldType = parseFieldType();\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Typedef is expected to have name and none found`\n    );\n\n    const leadingComments: Array<Comment> = getComments();\n\n    const annotations: Annotations | undefined = parseAnnotations();\n\n    return {\n      type: SyntaxType.TypedefDefinition,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      definitionType: type,\n      annotations,\n      comments: leadingComments,\n      loc: {\n        start: keywordToken.loc.start,\n        end: nameToken.loc.end,\n      },\n    };\n  }\n\n  // EnumDefinition → 'enum' Identifier '{' EnumMember* '} Annotations?'\n  function parseEnum(): EnumDefinition {\n    const leadingComments: Array<Comment> = getComments();\n    const _keywordToken: Token | null = consume(SyntaxType.EnumKeyword);\n    const keywordToken: Token = requireValue(\n      _keywordToken,\n      `'enum' keyword expected`\n    );\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Expected identifier for enum definition`\n    );\n\n    const openBrace: Token | null = consume(SyntaxType.LeftBraceToken);\n    requireValue(openBrace, `Expected opening brace`);\n\n    const members: Array<EnumMember> = parseEnumMembers();\n    const _closeBrace: Token | null = consume(SyntaxType.RightBraceToken);\n    const closeBrace: Token = requireValue(\n      _closeBrace,\n      `Expected closing brace`\n    );\n\n    const annotations: Annotations | undefined = parseAnnotations();\n\n    const loc: TextLocation = {\n      start: keywordToken.loc.start,\n      end: closeBrace.loc.end,\n    };\n\n    return {\n      type: SyntaxType.EnumDefinition,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      members,\n      annotations,\n      comments: leadingComments,\n      loc,\n    };\n  }\n\n  function parseEnumMembers(): Array<EnumMember> {\n    const members: Array<EnumMember> = [];\n    while (!check(SyntaxType.RightBraceToken)) {\n      if (check(SyntaxType.CommentBlock, SyntaxType.CommentLine)) {\n        advance();\n      } else {\n        members.push(parseEnumMember());\n\n        // consume list separator if there is one\n        readListSeparator();\n        if (isStatementBeginning(currentToken())) {\n          throw reportError(\n            `Closing curly brace expected, but new statement found`\n          );\n        } else if (check(SyntaxType.EOF)) {\n          throw reportError(\n            `Closing curly brace expected but reached end of file`\n          );\n        }\n      }\n    }\n\n    return members;\n  }\n\n  // EnumMember → (Identifier ('=' IntConstant)? Annotations? ListSeparator?)*\n  function parseEnumMember(): EnumMember {\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `EnumMember must have identifier`\n    );\n\n    let loc: TextLocation | null = null;\n    let initializer: IntConstant | null = null;\n    if (consume(SyntaxType.EqualToken) !== null) {\n      const _numToken: Token | null = consume(\n        SyntaxType.IntegerLiteral,\n        SyntaxType.HexLiteral\n      );\n      const numToken: Token = requireValue(\n        _numToken,\n        `Equals token \"=\" must be followed by an Integer`\n      );\n      initializer = parseIntValue(numToken);\n      loc = createTextLocation(nameToken.loc.start, initializer.loc.end);\n    } else {\n      loc = createTextLocation(nameToken.loc.start, nameToken.loc.end);\n    }\n\n    const annotations: Annotations | undefined = parseAnnotations();\n\n    return {\n      type: SyntaxType.EnumMember,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      initializer,\n      annotations,\n      comments: getComments(),\n      loc,\n    };\n  }\n\n  // StructLike → ('struct' | 'union' | 'exception') Identifier 'xsd_all'? '{' Field* '} Annotations?'\n  function parseStructLikeInterface(): StructLike {\n    const leadingComments: Array<Comment> = getComments();\n    const _keywordToken: Token | null = consume(\n      SyntaxType.StructKeyword,\n      SyntaxType.UnionKeyword,\n      SyntaxType.ExceptionKeyword\n    );\n    const keywordToken: Token = requireValue(\n      _keywordToken,\n      `'struct | union | exception' expected`\n    );\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Struct-like must have an identifier`\n    );\n\n    const openBrace: Token | null = consume(SyntaxType.LeftBraceToken);\n    requireValue(\n      openBrace,\n      `Struct-like body must begin with opening curly brace '{'`\n    );\n\n    const fields: Array<FieldDefinition> = parseFields();\n    const _closeBrace: Token | null = consume(SyntaxType.RightBraceToken);\n    const closeBrace: Token = requireValue(\n      _closeBrace,\n      `Struct-like body must end with a closing curly brace '}'`\n    );\n\n    const annotations: Annotations | undefined = parseAnnotations();\n\n    return {\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      fields,\n      annotations,\n      comments: leadingComments,\n      loc: {\n        start: keywordToken.loc.start,\n        end: closeBrace.loc.end,\n      },\n    };\n  }\n\n  // StructDefinition → 'struct' Identifier 'xsd_all'? '{' Field* '} Annotations?'\n  function parseStruct(): StructDefinition {\n    const parsedData: StructLike = parseStructLikeInterface();\n\n    return {\n      type: SyntaxType.StructDefinition,\n      name: parsedData.name,\n      fields: parsedData.fields,\n      annotations: parsedData.annotations,\n      comments: parsedData.comments,\n      loc: parsedData.loc,\n    };\n  }\n\n  // UnioinDefinition → 'union' Identifier 'xsd_all'? '{' Field* '} Annotations?'\n  function parseUnion(): UnionDefinition {\n    const parsedData: StructLike = parseStructLikeInterface();\n\n    return {\n      type: SyntaxType.UnionDefinition,\n      name: parsedData.name,\n      fields: parsedData.fields.map((next: FieldDefinition) => {\n        // As per the Thrift spec, all union fields are optional\n        next.requiredness = \"optional\";\n        return next;\n      }),\n      annotations: parsedData.annotations,\n      comments: parsedData.comments,\n      loc: parsedData.loc,\n    };\n  }\n\n  // ExceptionDefinition → 'exception' Identifier '{' Field* '} Annotations?'\n  function parseException(): ExceptionDefinition {\n    const parsedData: StructLike = parseStructLikeInterface();\n\n    return {\n      type: SyntaxType.ExceptionDefinition,\n      name: parsedData.name,\n      fields: parsedData.fields,\n      annotations: parsedData.annotations,\n      comments: parsedData.comments,\n      loc: parsedData.loc,\n    };\n  }\n\n  function parseFields(): Array<FieldDefinition> {\n    const fields: Array<FieldDefinition> = [];\n\n    while (!check(SyntaxType.RightBraceToken)) {\n      if (check(SyntaxType.CommentBlock, SyntaxType.CommentLine)) {\n        advance();\n      } else {\n        fields.push(parseField());\n\n        if (isStatementBeginning(currentToken())) {\n          throw reportError(\n            `Closing curly brace expected, but new statement found`\n          );\n        } else if (check(SyntaxType.EOF)) {\n          throw reportError(\n            `Closing curly brace expected but reached end of file`\n          );\n        }\n      }\n    }\n\n    return fields;\n  }\n\n  // Field → FieldID? FieldReq? FieldType Identifier ('= ConstValue)? XsdFieldOptions Annotations? ListSeparator?\n  function parseField(): FieldDefinition {\n    const startLoc: TextLocation = currentToken().loc;\n    const fieldID: FieldID | null = parseFieldId();\n    const fieldRequired: FieldRequired | null = parserequireValuedness();\n    const fieldType: FieldType = parseFieldType();\n    // 在scanner处理的时候，把list直接识别成SyntaxType.ListKeyword，但是根据idl来看这样是合法的\n    // 实际应该集合parse的上下文进行修正\n    const _nameToken: Token | null = parseValidIdentifier();\n\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Unable to find identifier for field`\n    );\n\n    const defaultValue: ConstValue | null = parseValueAssignment();\n    const annotations: Annotations | undefined = parseAnnotations();\n    const listSeparator: Token | null = readListSeparator();\n\n    const endLoc: TextLocation =\n      listSeparator !== null\n        ? listSeparator.loc\n        : defaultValue !== null\n          ? defaultValue.loc\n          : nameToken.loc;\n\n    const location: TextLocation = createTextLocation(\n      startLoc.start,\n      endLoc.end\n    );\n\n    return {\n      type: SyntaxType.FieldDefinition,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      fieldID,\n      fieldType,\n      requiredness: fieldRequired,\n      defaultValue,\n      comments: getComments(),\n      annotations,\n      loc: location,\n    };\n  }\n\n  // ListSeparator → ',' | ';'\n  function readListSeparator(): Token | null {\n    if (check(SyntaxType.CommaToken, SyntaxType.SemicolonToken)) {\n      return advance();\n    }\n\n    return null;\n  }\n\n  // FieldRequired → 'required' | 'optional'\n  function parserequireValuedness(): FieldRequired | null {\n    const current: Token = currentToken();\n    if (current.text === \"required\" || current.text === \"optional\") {\n      advance();\n      return current.text;\n    }\n\n    return null;\n  }\n\n  // FieldID → IntConstant ':'\n  function parseFieldId(): FieldID | null {\n    if (\n      currentToken().type === SyntaxType.IntegerLiteral &&\n      peek().type === SyntaxType.ColonToken\n    ) {\n      const fieldIDToken: Token | null = consume(SyntaxType.IntegerLiteral);\n      const colonToken: Token | null = consume(SyntaxType.ColonToken);\n\n      // return value of number token\n      return createFieldID(\n        parseInt(fieldIDToken!.text, 10),\n        createTextLocation(fieldIDToken!.loc.start, colonToken!.loc.end)\n      );\n    } else {\n      return null;\n    }\n  }\n\n  // ConstValue → Literal | ConstMap | ConstList\n  function parseValue(): ConstValue | null {\n    const next: Token = advance();\n    switch (next.type) {\n      case SyntaxType.Identifier:\n        return createIdentifier(next.text, next.loc);\n\n      case SyntaxType.StringLiteral:\n        return createStringLiteral(next.text, next.loc);\n\n      case SyntaxType.IntegerLiteral:\n      case SyntaxType.HexLiteral:\n        return parseIntValue(next);\n\n      case SyntaxType.FloatLiteral:\n      case SyntaxType.ExponentialLiteral:\n        return parseDoubleValue(next);\n\n      case SyntaxType.TrueKeyword:\n        return createBooleanLiteral(true, next.loc);\n\n      case SyntaxType.FalseKeyword:\n        return createBooleanLiteral(false, next.loc);\n\n      case SyntaxType.LeftBraceToken:\n        return parseMapValue();\n\n      case SyntaxType.LeftBracketToken:\n        return parseListValue();\n\n      default:\n        return null;\n    }\n  }\n\n  function parseIntValue(token: Token): IntConstant {\n    switch (token.type) {\n      case SyntaxType.IntegerLiteral:\n        return createIntConstant(\n          createIntegerLiteral(token.text, token.loc),\n          token.loc\n        );\n\n      case SyntaxType.HexLiteral:\n        return createIntConstant(\n          createHexLiteral(token.text, token.loc),\n          token.loc\n        );\n\n      default:\n        throw reportError(`IntConstant expected but found: ${token.type}`);\n    }\n  }\n\n  function parseDoubleValue(token: Token): DoubleConstant {\n    switch (token.type) {\n      case SyntaxType.FloatLiteral:\n        return createDoubleConstant(\n          createFloatLiteral(token.text, token.loc),\n          token.loc\n        );\n\n      case SyntaxType.ExponentialLiteral:\n        return createDoubleConstant(\n          createExponentialLiteral(token.text, token.loc),\n          token.loc\n        );\n\n      default:\n        throw reportError(`DoubleConstant expected but found: ${token.type}`);\n    }\n  }\n\n  // ConstMap → '{' (ConstValue ':' ConstValue ListSeparator?)* '}'\n  function parseMapValue(): ConstMap {\n    // The parseValue method has already advanced the cursor\n    const startLoc: TextLocation = currentToken().loc;\n    const properties: Array<PropertyAssignment> = check(\n      SyntaxType.RightBraceToken\n    )\n      ? []\n      : readMapValues();\n    const _closeBrace: Token | null = consume(SyntaxType.RightBraceToken);\n    const closeBrace: Token = requireValue(\n      _closeBrace,\n      `Closing brace missing from map definition`\n    );\n\n    const endLoc: TextLocation = closeBrace.loc;\n    const location: TextLocation = {\n      start: startLoc.start,\n      end: endLoc.end,\n    };\n\n    return createConstMap(properties, location);\n  }\n\n  // ConstList → '[' (ConstValue ListSeparator?)* ']'\n  function parseListValue(): ConstList {\n    // The parseValue method has already advanced the cursor\n    const startLoc: TextLocation = currentToken().loc;\n    const elements: Array<ConstValue> = check(SyntaxType.RightBracketToken)\n      ? []\n      : readListValues();\n    const _closeBrace: Token | null = consume(SyntaxType.RightBracketToken);\n    const closeBrace: Token = requireValue(\n      _closeBrace,\n      `Closing square-bracket missing from list definition`\n    );\n    const endLoc: TextLocation = closeBrace.loc;\n\n    return createConstList(elements, {\n      start: startLoc.start,\n      end: endLoc.end,\n    });\n  }\n\n  function readMapValues(): Array<PropertyAssignment> {\n    const properties: Array<PropertyAssignment> = [];\n    while (true) {\n      const _key: ConstValue | null = parseValue();\n      const key: ConstValue = requireValue(_key, \"Key expected for map value\");\n      const semicolon: Token | null = consume(SyntaxType.ColonToken);\n      requireValue(\n        semicolon,\n        `Semicolon expected after key in map property assignment`\n      );\n      const _value: ConstValue | null = parseValue();\n      const value: ConstValue = requireValue(_value, \"\");\n\n      properties.push(\n        creataePropertyAssignment(key, value, {\n          start: key.loc.start,\n          end: value.loc.end,\n        })\n      );\n\n      if (check(SyntaxType.CommaToken)) {\n        advance();\n\n        // trailing comma\n        if (check(SyntaxType.RightBraceToken)) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return properties;\n  }\n\n  function readListValues(): Array<ConstValue> {\n    const elements: Array<ConstValue> = [];\n    while (true) {\n      const value: ConstValue | null = parseValue();\n      if (value !== null) {\n        elements.push(value);\n      }\n\n      if (check(SyntaxType.CommaToken, SyntaxType.SemicolonToken)) {\n        advance();\n\n        // trailing comma\n        if (check(SyntaxType.RightBracketToken)) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    return elements;\n  }\n\n  // FunctionType → FieldType | 'void'\n  function parseFunctionType(): FunctionType {\n    const typeToken: Token | null = consume(SyntaxType.VoidKeyword);\n    if (typeToken !== null) {\n      return {\n        type: SyntaxType.VoidKeyword,\n        loc: typeToken.loc,\n      };\n    } else {\n      return parseFieldType();\n    }\n  }\n\n  const IdentifierRegExp = /^[_a-zA-Z][-._a-zA-Z0-9]*$/;\n\n  function parseValidIdentifier(): Token | null {\n    const token = advance();\n\n    // 参看 scanner 的 identifier 的判断\n    if (IdentifierRegExp.test(token.text)) {\n      token.type = SyntaxType.Identifier;\n\n      return token;\n    }\n\n    return null;\n  }\n\n  // FieldType → Identifier | BaseType | ContainerType\n  function parseFieldType(): FieldType {\n    const typeToken: Token = advance();\n    switch (typeToken.type) {\n      case SyntaxType.Identifier:\n        let text = typeToken.text;\n        if (options?.reservedWord === \"escape\") {\n          text = escapeReservedWordForIdentifier(typeToken.text);\n        }\n\n        return createIdentifier(text, typeToken.loc, parseAnnotations());\n\n      case SyntaxType.MapKeyword:\n        return parseMapType();\n\n      case SyntaxType.ListKeyword:\n        return parseListType();\n\n      case SyntaxType.SetKeyword:\n        return parseSetType();\n\n      case SyntaxType.BinaryKeyword:\n      case SyntaxType.BoolKeyword:\n      case SyntaxType.ByteKeyword:\n      case SyntaxType.StringKeyword:\n      case SyntaxType.I8Keyword:\n      case SyntaxType.I16Keyword:\n      case SyntaxType.I32Keyword:\n      case SyntaxType.I64Keyword:\n      case SyntaxType.Int8Keyword:\n      case SyntaxType.Int16Keyword:\n      case SyntaxType.Int32Keyword:\n      case SyntaxType.Int64Keyword:\n      case SyntaxType.DoubleKeyword:\n        return createKeywordFieldType(\n          typeToken.type,\n          typeToken.loc,\n          parseAnnotations()\n        );\n\n      default:\n        throw reportError(`FieldType expected but found: ${typeToken.type}`);\n    }\n  }\n\n  // MapType → 'map' CppType? '<' FieldType ',' FieldType '>'\n  function parseMapType(): MapType {\n    const _openBracket: Token | null = consume(SyntaxType.LessThanToken);\n    const openBracket: Token = requireValue(\n      _openBracket,\n      `Map needs to defined contained types`\n    );\n\n    const keyType: FieldType = parseFieldType();\n    const _commaToken: Token | null = consume(SyntaxType.CommaToken);\n    const commaToken: Token = requireValue(\n      _commaToken,\n      `Comma expected to separate map types <key, value>`\n    );\n\n    const valueType: FieldType = parseFieldType();\n    const _closeBracket: Token | null = consume(SyntaxType.GreaterThanToken);\n    const closeBracket: Token = requireValue(\n      _closeBracket,\n      `Map needs to defined contained types`\n    );\n\n    const location: TextLocation = {\n      start: openBracket.loc.start,\n      end: closeBracket.loc.end,\n    };\n\n    return createMapFieldType(keyType, valueType, location, parseAnnotations());\n  }\n\n  // SetType → 'set' CppType? '<' FieldType '>'\n  function parseSetType(): SetType {\n    const _openBracket: Token | null = consume(SyntaxType.LessThanToken);\n    const openBracket: Token = requireValue(\n      _openBracket,\n      `Map needs to defined contained types`\n    );\n\n    const valueType: FieldType = parseFieldType();\n    const _closeBracket: Token | null = consume(SyntaxType.GreaterThanToken);\n    const closeBracket: Token = requireValue(\n      _closeBracket,\n      `Map needs to defined contained types`\n    );\n\n    return {\n      type: SyntaxType.SetType,\n      valueType,\n      loc: {\n        start: openBracket.loc.start,\n        end: closeBracket.loc.end,\n      },\n      annotations: parseAnnotations(),\n    };\n  }\n\n  // ListType → 'list' '<' FieldType '>' CppType?\n  function parseListType(): ListType {\n    const _openBracket: Token | null = consume(SyntaxType.LessThanToken);\n    const openBracket: Token = requireValue(\n      _openBracket,\n      `Map needs to defined contained types`\n    );\n\n    const valueType: FieldType = parseFieldType();\n    const _closeBracket: Token | null = consume(SyntaxType.GreaterThanToken);\n    const closeBracket: Token = requireValue(\n      _closeBracket,\n      `Map needs to defined contained types`\n    );\n\n    return {\n      type: SyntaxType.ListType,\n      valueType,\n      loc: {\n        start: openBracket.loc.start,\n        end: closeBracket.loc.end,\n      },\n      annotations: parseAnnotations(),\n    };\n  }\n\n  const ReservedWordsForIdentifierRegExp = new RegExp(\n    `(?<=\\\\.|^)(?:${RESERVEDWORDS.map((v) => `(${v})`).join(\"|\")})(?=\\\\.|$)`,\n    \"g\"\n  );\n\n  function escapeReservedWordForIdentifier(text: string): string {\n    const originText = text;\n    let replaceCount = 0;\n\n    const replacedText = originText.replace(\n      ReservedWordsForIdentifierRegExp,\n      (value: string) => {\n        replaceCount++;\n\n        return `${value[0].toUpperCase()}${value.substring(1)}`;\n      }\n    );\n\n    if (replaceCount) {\n      return replacedText;\n    }\n\n    return originText;\n  }\n\n  function consumeComments(): void {\n    while (true) {\n      const next: Token = tokens[currentIndex];\n      switch (next.type) {\n        case SyntaxType.CommentBlock:\n          comments.push({\n            type: next.type,\n            value: next.text.split(\"\\n\"),\n            loc: next.loc,\n          });\n          currentIndex++;\n          break;\n\n        case SyntaxType.CommentLine:\n          comments.push({\n            type: next.type,\n            value: next.text,\n            loc: next.loc,\n          });\n          currentIndex++;\n          break;\n\n        default:\n          return;\n      }\n    }\n  }\n\n  function currentToken(): Token {\n    consumeComments();\n    return tokens[currentIndex];\n  }\n\n  function previousToken(): Token {\n    return tokens[currentIndex - 1];\n  }\n\n  function peek(): Token {\n    return tokens[currentIndex + 1];\n  }\n\n  // Does the current token match the given type\n  function check(...types: Array<SyntaxType>): boolean {\n    for (const type of types) {\n      if (type === currentToken().type) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // Does the current token match the given text\n  function checkText(...strs: Array<string>): boolean {\n    for (const str of strs) {\n      if (str === currentToken().text) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // requireToken the current token to match given type and advance, otherwise return null\n  function consume(...types: Array<SyntaxType>): Token | null {\n    for (const type of types) {\n      if (check(type)) {\n        return advance();\n      }\n    }\n\n    return null;\n  }\n\n  // Move the cursor forward and return the previous token\n  function advance(): Token {\n    if (!isAtEnd()) {\n      currentIndex += 1;\n    }\n\n    return previousToken();\n  }\n\n  function isAtEnd(): boolean {\n    return (\n      currentIndex >= tokens.length || currentToken().type === SyntaxType.EOF\n    );\n  }\n\n  function getComments(): Array<Comment> {\n    const current: Array<Comment> = comments;\n    comments = [];\n    return current;\n  }\n\n  function reportError(msg: string): Error {\n    return new ParseError(msg, previousToken().loc);\n  }\n\n  // Throw if the given value doesn't exist.\n  function requireValue<T>(val: T | null, msg: string): T {\n    if (val === null || val === undefined) {\n      throw reportError(msg);\n    } else {\n      return val;\n    }\n  }\n\n  return {\n    parse,\n    synchronize,\n  };\n}\n","/* eslint-disable */\nimport { ErrorReporter, noopReporter } from \"./debugger\";\nimport { createScanError, createToken } from \"./factory\";\nimport { KEYWORDS } from \"./keywords\";\nimport { SyntaxType, TextLocation, Token } from \"./types\";\n\nfunction isDigit(value: string): boolean {\n  return value >= \"0\" && value <= \"9\";\n}\n\nfunction isAlpha(value: string): boolean {\n  return (value >= \"a\" && value <= \"z\") || (value >= \"A\" && value <= \"Z\");\n}\n\n// The first character of an Identifier can be a letter or underscore\nfunction isAlphaOrUnderscore(value: string): boolean {\n  return isAlpha(value) || value === \"_\";\n}\n\nfunction isValidIdentifier(value: string): boolean {\n  return (\n    isAlphaOrUnderscore(value) ||\n    isDigit(value) ||\n    value === \".\" ||\n    value === \"-\"\n  );\n}\n\nfunction isHexDigit(value: string): boolean {\n  return (\n    (value >= \"0\" && value <= \"9\") ||\n    (value >= \"A\" && value <= \"F\") ||\n    (value >= \"a\" && value <= \"f\")\n  );\n}\n\nfunction isWhiteSpace(char: string): boolean {\n  switch (char) {\n    case \" \":\n    case \"\\r\":\n    case \"\\t\":\n    case \"\\n\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass ScanError extends Error {\n  public message: string;\n  public loc: TextLocation;\n  constructor(msg: string, loc: TextLocation) {\n    super(msg);\n    this.message = msg;\n    this.loc = loc;\n  }\n}\n\nexport interface Scanner {\n  scan(): Array<Token>;\n  syncronize(): void;\n}\n\nexport function createScanner(\n  src: string,\n  report: ErrorReporter = noopReporter\n) {\n  const source: string = src;\n  const tokens: Array<Token> = [];\n  let line: number = 1;\n  let column: number = 1;\n  let startLine: number = 1;\n  let startColumn: number = 1;\n  let startIndex: number = 0;\n  let currentIndex: number = 0;\n\n  function scan(): Array<Token> {\n    while (!isAtEnd()) {\n      try {\n        startIndex = currentIndex;\n        startLine = line;\n        startColumn = column;\n        scanToken();\n      } catch (e: any) {\n        report(createScanError(e.message, e.loc));\n      }\n    }\n\n    startIndex = currentIndex;\n    addToken(SyntaxType.EOF);\n\n    return tokens;\n  }\n\n  // Find the beginning of the next word to restart parse after error\n  function syncronize(): void {\n    while (!isAtEnd() && !isWhiteSpace(current())) {\n      advance();\n    }\n  }\n\n  function scanToken(): void {\n    const next = advance();\n    switch (next) {\n      case \" \":\n      case \"\\r\":\n      case \"\\t\":\n        // Ignore whitespace.\n        break;\n\n      case \"\\n\":\n        nextLine();\n        break;\n\n      case \"&\":\n        // Thirft supports (undocumented by the grammar) a syntax for c-style pointers\n        // Pointers are indicated by the '&' token. As these are not relevant to JavaScript we\n        // drop them here. This may not be the best thing to do, perhaps should leave them in\n        // the parse tree and allow consumers to deal.\n        break;\n\n      case \"=\":\n        addToken(SyntaxType.EqualToken);\n        break;\n\n      case \"(\":\n        addToken(SyntaxType.LeftParenToken);\n        break;\n\n      case \")\":\n        addToken(SyntaxType.RightParenToken);\n        break;\n\n      case \"{\":\n        addToken(SyntaxType.LeftBraceToken);\n        break;\n\n      case \"}\":\n        addToken(SyntaxType.RightBraceToken);\n        break;\n\n      case \"[\":\n        addToken(SyntaxType.LeftBracketToken);\n        break;\n\n      case \"]\":\n        addToken(SyntaxType.RightBracketToken);\n        break;\n\n      case \";\":\n        addToken(SyntaxType.SemicolonToken);\n        break;\n\n      case \",\":\n        addToken(SyntaxType.CommaToken);\n        break;\n\n      // Strings can use single or double quotes\n      case '\"':\n      case \"'\":\n        string(next);\n        break;\n\n      case \":\":\n        addToken(SyntaxType.ColonToken);\n        break;\n\n      case \"#\":\n        singleLineComment();\n        break;\n\n      case \"/\":\n        if (peek() === \"/\") {\n          singleLineComment();\n        } else if (peek() === \"*\") {\n          multilineComment();\n        } else {\n          reportError(`Unexpected token: ${next}`);\n        }\n        break;\n\n      case \"<\":\n        addToken(SyntaxType.LessThanToken);\n        break;\n\n      case \">\":\n        addToken(SyntaxType.GreaterThanToken);\n        break;\n\n      case \"-\":\n        if (isDigit(peek())) {\n          number();\n        } else {\n          addToken(SyntaxType.MinusToken);\n        }\n        break;\n\n      default:\n        if (isDigit(next)) {\n          number();\n        } else if (isAlphaOrUnderscore(next)) {\n          identifier();\n        } else if (isValidIdentifier(next)) {\n          reportError(\n            `Invalid identifier '${next}': Identifiers must begin with a letter or underscore`\n          );\n        } else {\n          reportError(`Unexpected token: ${next}`);\n        }\n    }\n  }\n\n  function identifier(): void {\n    while (!isAtEnd() && peek() !== \"\\n\" && isValidIdentifier(peek())) {\n      advance();\n    }\n\n    const literal: string = source.substring(startIndex, currentIndex);\n\n    const isKeyword = Object.keys(KEYWORDS).includes(literal);\n    if (!isKeyword) {\n      addToken(SyntaxType.Identifier, literal);\n    } else {\n      const type: SyntaxType = KEYWORDS[literal];\n      addToken(type, literal);\n    }\n  }\n\n  function number(): void {\n    if (current() === \"0\" && (consume(\"x\") || consume(\"X\"))) {\n      hexadecimal();\n    } else {\n      integer();\n\n      if (peek() === \"e\" || peek() === \"E\") {\n        enotation();\n      } else if (peek() === \".\" && isDigit(peekNext())) {\n        float();\n      } else {\n        commitToken(SyntaxType.IntegerLiteral);\n      }\n    }\n  }\n\n  function hexadecimal(): void {\n    while (!isAtEnd() && peek() !== \"\\n\" && isHexDigit(peek())) {\n      advance();\n    }\n\n    commitToken(SyntaxType.HexLiteral);\n  }\n\n  function enotation(): void {\n    consume(\"e\") || consume(\"E\");\n    consume(\"-\") || consume(\"+\");\n    if (isDigit(peek())) {\n      integer();\n      commitToken(SyntaxType.ExponentialLiteral);\n    } else {\n      reportError(`Invalid use of e-notation`);\n    }\n  }\n\n  function float(): void {\n    consume(\".\");\n    integer();\n\n    if (peek() === \"e\" || peek() === \"E\") {\n      enotation();\n    } else {\n      commitToken(SyntaxType.FloatLiteral);\n    }\n  }\n\n  function integer(): void {\n    while (!isAtEnd() && peek() !== \"\\n\" && isDigit(peek())) {\n      advance();\n    }\n  }\n\n  function singleLineComment(): void {\n    let comment: string = \"\";\n\n    while (true) {\n      if (\n        current() === \"\\n\" ||\n        isAtEnd() ||\n        (current() !== \"/\" && current() !== \"#\" && current() !== \" \")\n      ) {\n        break;\n      } else {\n        advance();\n      }\n    }\n\n    if (current() !== \"\\n\") {\n      // A comment goes until the end of the line.\n      while (peek() !== \"\\n\" && !isAtEnd()) {\n        comment += current();\n        advance();\n      }\n\n      comment += current();\n    }\n\n    addToken(SyntaxType.CommentLine, comment.trim());\n  }\n\n  // TODO: optimize the logic\n  function multilineComment(): void {\n    let comment: string = \"\";\n    let cursor: number = 0;\n\n    while (true) {\n      if (\n        current() === \"\\n\" ||\n        isAtEnd() ||\n        (current() !== \"/\" && current() !== \"*\") ||\n        (current() === \"*\" && peek() === \"*\" && peekNext() === \"/\")\n      ) {\n        break;\n      } else {\n        advance();\n      }\n    }\n\n    while (true) {\n      if (current() === \"\\n\") {\n        nextLine();\n      }\n\n      // A comment goes until we find a comment terminator (*/).\n      if ((peek() === \"*\" && peekNext() === \"/\") || isAtEnd()) {\n        advance();\n        advance();\n        break;\n      }\n\n      if (\n        comment.charAt(cursor - 1) === \"\\n\" &&\n        (peek() === \" \" || peek() === \"*\")\n      ) {\n        /**\n         * We ignore stars and spaces after a new line to normalize comment formatting.\n         * We're only keeping the text of the comment without the extranious formatting.\n         */\n      } else {\n        comment += current();\n        cursor += 1;\n      }\n\n      advance();\n\n      // A comment goes until we find a comment terminator (*/).\n      if ((peek() === \"*\" && peekNext() === \"/\") || isAtEnd()) {\n        advance();\n        advance();\n        break;\n      }\n    }\n\n    addToken(SyntaxType.CommentBlock, comment.trim());\n  }\n\n  function string(terminator: string): void {\n    while (!isAtEnd() && peek() !== terminator) {\n      if (peek() === \"\\n\") {\n        nextLine();\n      }\n      if (peek() === \"\\\\\") {\n        advance();\n      }\n\n      advance();\n    }\n\n    if (isAtEnd() && previous() !== terminator) {\n      reportError(`String must be terminated with ${terminator}`);\n    } else {\n      // advance past closing \"\n      advance();\n      // We use \"+ 1\" and \"- 1\" to remove the quote markes from the string and unsescape escaped terminators\n      const literal: string = source\n        .substring(startIndex + 1, currentIndex - 1)\n        .replace(/\\\\(\\\"|\\')/g, \"$1\");\n      addToken(SyntaxType.StringLiteral, literal);\n    }\n  }\n\n  function consume(text: string): boolean {\n    if (peek() === text) {\n      advance();\n      return true;\n    }\n\n    return false;\n  }\n\n  function advance(): string {\n    currentIndex++;\n    column++;\n    return source.charAt(currentIndex - 1);\n  }\n\n  function previous(): string {\n    return source.charAt(currentIndex - 2);\n  }\n\n  function current(): string {\n    return source.charAt(currentIndex - 1);\n  }\n\n  function peek(): string {\n    return source.charAt(currentIndex);\n  }\n\n  function peekNext(): string {\n    return source.charAt(currentIndex + 1);\n  }\n\n  function nextLine() {\n    line++;\n    column = 1;\n  }\n\n  function commitToken(type: SyntaxType): void {\n    const literal: string = source.substring(startIndex, currentIndex);\n    addToken(type, literal);\n  }\n\n  function currentLocation(): TextLocation {\n    return {\n      start: {\n        line: startLine,\n        column: startColumn,\n        index: startIndex,\n      },\n      end: {\n        line,\n        column,\n        index: currentIndex,\n      },\n    };\n  }\n\n  function addToken(type: SyntaxType, value: string = \"\"): void {\n    const loc: TextLocation = currentLocation();\n    tokens.push(createToken(type, value, loc));\n  }\n\n  function isAtEnd(): boolean {\n    return currentIndex >= source.length;\n  }\n\n  function reportError(msg: string): void {\n    throw new ScanError(msg, currentLocation());\n  }\n\n  return {\n    scan,\n    syncronize,\n  };\n}\n","export interface ThriftError {\n    type: ErrorType\n    message: string\n    loc: TextLocation\n}\n\nexport interface ParseError extends ThriftError {\n    type: ErrorType.ParseError\n}\n\nexport interface ScanError extends ThriftError {\n    type: ErrorType.ScanError\n}\n\nexport interface Node {\n    type: SyntaxType\n}\n\nexport interface SyntaxNode extends Node {\n    loc: TextLocation\n}\n\nexport interface StructLike {\n    name: Identifier\n    fields: Array<FieldDefinition>\n    annotations?: Annotations\n    comments: Array<Comment>\n    loc: TextLocation\n}\n\nexport interface TextLocation {\n    start: TextPosition\n    end: TextPosition\n}\n\nexport interface TextPosition {\n    line: number\n    column: number\n    index: number\n}\n\nexport interface Token extends SyntaxNode {\n    text: string\n}\n\nexport interface ThriftDocument extends Node {\n    type: SyntaxType.ThriftDocument\n    body: Array<ThriftStatement>\n    tokens?: Array<Token>\n}\n\nexport interface ThriftErrors {\n    type: SyntaxType.ThriftErrors\n    errors: Array<ThriftError>\n}\n\nexport type ThriftStatement =\n    | NamespaceDefinition\n    | IncludeDefinition\n    | CppIncludeDefinition\n    | ConstDefinition\n    | StructDefinition\n    | EnumDefinition\n    | ExceptionDefinition\n    | UnionDefinition\n    | TypedefDefinition\n    | ServiceDefinition\n\nexport type CommentType = SyntaxType.CommentLine | SyntaxType.CommentBlock\n\nexport type Comment = CommentLine | CommentBlock\n\nexport interface CommentLine extends SyntaxNode {\n    type: SyntaxType.CommentLine\n    value: string\n}\n\nexport interface CommentBlock extends SyntaxNode {\n    type: SyntaxType.CommentBlock\n    value: Array<string>\n}\n\nexport interface Annotations extends SyntaxNode {\n    annotations: Array<Annotation>\n}\n\nexport interface Annotation extends SyntaxNode {\n    name: Identifier\n    value?: StringLiteral\n}\n\nexport interface PrimarySyntax extends SyntaxNode {\n    comments: Array<Comment>\n    commentsBefore?: Array<Comment>\n    commentsAfter?: Array<Comment>\n}\n\nexport type FieldType = BaseType | ContainerType | Identifier\n\nexport type FunctionType = FieldType | VoidType\n\nexport type KeywordType =\n    | SyntaxType.StringKeyword\n    | SyntaxType.DoubleKeyword\n    | SyntaxType.BoolKeyword\n    | SyntaxType.I8Keyword\n    | SyntaxType.I16Keyword\n    | SyntaxType.I32Keyword\n    | SyntaxType.I64Keyword\n    | SyntaxType.Int8Keyword\n    | SyntaxType.Int16Keyword\n    | SyntaxType.Int32Keyword\n    | SyntaxType.Int64Keyword\n    | SyntaxType.BinaryKeyword\n    | SyntaxType.ByteKeyword\n\nexport interface VoidType extends SyntaxNode {\n    type: SyntaxType.VoidKeyword\n}\n\nexport type ContainerType = SetType | MapType | ListType\n\nexport interface BaseType extends SyntaxNode {\n    type: KeywordType\n    annotations?: Annotations\n}\n\nexport interface SetType extends SyntaxNode {\n    type: SyntaxType.SetType\n    valueType: FieldType\n    annotations?: Annotations\n}\n\nexport interface ListType extends SyntaxNode {\n    type: SyntaxType.ListType\n    valueType: FieldType\n    annotations?: Annotations\n}\n\nexport interface MapType extends SyntaxNode {\n    type: SyntaxType.MapType\n    keyType: FieldType\n    valueType: FieldType\n    annotations?: Annotations\n}\n\nexport type ConstValue =\n    | StringLiteral\n    | IntConstant\n    | DoubleConstant\n    | BooleanLiteral\n    | ConstMap\n    | ConstList\n    | Identifier\n\nexport interface NamespaceDefinition extends PrimarySyntax {\n    type: SyntaxType.NamespaceDefinition\n    scope: Identifier\n    name: Identifier\n}\n\nexport interface ConstDefinition extends PrimarySyntax {\n    type: SyntaxType.ConstDefinition\n    name: Identifier\n    fieldType: FieldType\n    initializer: ConstValue\n    annotations?: Annotations\n}\n\nexport type FieldRequired = 'required' | 'optional'\n\nexport interface IncludeDefinition extends PrimarySyntax {\n    type: SyntaxType.IncludeDefinition\n    path: StringLiteral\n}\n\nexport interface CppIncludeDefinition extends PrimarySyntax {\n    type: SyntaxType.CppIncludeDefinition\n    path: StringLiteral\n}\n\nexport interface InterfaceWithFields extends PrimarySyntax {\n    name: Identifier\n    fields: Array<FieldDefinition>\n    annotations?: Annotations\n}\n\nexport interface StructDefinition extends InterfaceWithFields {\n    type: SyntaxType.StructDefinition\n}\n\nexport interface UnionDefinition extends InterfaceWithFields {\n    type: SyntaxType.UnionDefinition\n}\n\nexport interface ExceptionDefinition extends InterfaceWithFields {\n    type: SyntaxType.ExceptionDefinition\n}\n\nexport interface FieldDefinition extends PrimarySyntax {\n    type: SyntaxType.FieldDefinition\n    name: Identifier\n    fieldID: FieldID | null\n    fieldType: FunctionType\n    requiredness: FieldRequired | null\n    defaultValue: ConstValue | null\n    annotations?: Annotations\n}\n\nexport interface FieldID extends SyntaxNode {\n    type: SyntaxType.FieldID\n    value: number\n}\n\nexport interface EnumDefinition extends PrimarySyntax {\n    type: SyntaxType.EnumDefinition\n    name: Identifier\n    members: Array<EnumMember>\n    annotations?: Annotations\n}\n\nexport interface EnumMember extends PrimarySyntax {\n    type: SyntaxType.EnumMember\n    name: Identifier\n    initializer: IntConstant | null\n    annotations?: Annotations\n}\n\nexport interface TypedefDefinition extends PrimarySyntax {\n    type: SyntaxType.TypedefDefinition\n    name: Identifier\n    definitionType: FieldType\n    annotations?: Annotations\n}\n\nexport interface ServiceDefinition extends PrimarySyntax {\n    type: SyntaxType.ServiceDefinition\n    name: Identifier\n    extends: Identifier | null\n    functions: Array<FunctionDefinition>\n    annotations?: Annotations\n}\n\nexport interface FunctionDefinition extends PrimarySyntax {\n    type: SyntaxType.FunctionDefinition\n    name: Identifier\n    oneway: boolean\n    returnType: FunctionType\n    fields: Array<FieldDefinition>\n    throws: Array<FieldDefinition>\n    modifiers: Array<Token>\n    annotations?: Annotations\n}\n\nexport interface ParametersDefinition extends SyntaxNode {\n    type: SyntaxType.ParametersDefinition\n    fields: Array<FieldDefinition>\n}\n\nexport interface ThrowsDefinition extends SyntaxNode {\n    type: SyntaxType.ThrowsDefinition\n    fields: Array<FieldDefinition>\n}\n\nexport interface StringLiteral extends SyntaxNode {\n    type: SyntaxType.StringLiteral\n    value: string\n}\n\nexport interface BooleanLiteral extends SyntaxNode {\n    type: SyntaxType.BooleanLiteral\n    value: boolean\n}\n\nexport interface IntegerLiteral extends SyntaxNode {\n    type: SyntaxType.IntegerLiteral\n    value: string\n}\n\nexport interface HexLiteral extends SyntaxNode {\n    type: SyntaxType.HexLiteral\n    value: string\n}\n\nexport interface FloatLiteral extends SyntaxNode {\n    type: SyntaxType.FloatLiteral\n    value: string\n}\n\nexport interface ExponentialLiteral extends SyntaxNode {\n    type: SyntaxType.ExponentialLiteral\n    value: string\n}\n\nexport interface IntConstant extends SyntaxNode {\n    type: SyntaxType.IntConstant\n    value: IntegerLiteral | HexLiteral\n}\n\nexport interface DoubleConstant extends SyntaxNode {\n    type: SyntaxType.DoubleConstant\n    value: FloatLiteral | ExponentialLiteral\n}\n\nexport interface ConstMap extends SyntaxNode {\n    type: SyntaxType.ConstMap\n    properties: Array<PropertyAssignment>\n}\n\nexport interface ConstList extends SyntaxNode {\n    type: SyntaxType.ConstList\n    elements: Array<ConstValue>\n}\n\nexport interface PropertyAssignment extends SyntaxNode {\n    type: SyntaxType.PropertyAssignment\n    name: ConstValue\n    initializer: ConstValue\n}\n\nexport interface Identifier extends SyntaxNode {\n    type: SyntaxType.Identifier\n    value: string\n    annotations?: Annotations\n}\n\nexport enum ErrorType {\n    ParseError = 'ParseError',\n    ScanError = 'ScanError',\n}\n\nexport enum SyntaxType {\n    ThriftDocument = 'ThriftDocument',\n    ThriftErrors = 'ThriftErrors',\n\n    Identifier = 'Identifier',\n    FieldID = 'FieldID',\n\n    // Statements\n    NamespaceDefinition = 'NamespaceDefinition',\n    IncludeDefinition = 'IncludeDefinition',\n    CppIncludeDefinition = 'CppIncludeDefinition',\n    ConstDefinition = 'ConstDefinition',\n    StructDefinition = 'StructDefinition',\n    EnumDefinition = 'EnumDefinition',\n    ServiceDefinition = 'ServiceDefinition',\n    ExceptionDefinition = 'ExceptionDefinition',\n    TypedefDefinition = 'TypedefDefinition',\n    UnionDefinition = 'UnionDefinition',\n\n    // Fields\n    FieldDefinition = 'FieldDefinition',\n    FunctionDefinition = 'FunctionDefinition',\n    ParametersDefinition = 'ParametersDefinition',\n    ThrowsDefinition = 'ThrowsDefinition',\n\n    // Type Annotations\n    FieldType = 'FieldType',\n    BaseType = 'BaseType',\n    SetType = 'SetType',\n    MapType = 'MapType',\n    ListType = 'ListType',\n\n    // Values\n    ConstValue = 'ConstValue',\n    IntConstant = 'IntConstant',\n    DoubleConstant = 'DoubleConstant',\n\n    ConstList = 'ConstList',\n    ConstMap = 'ConstMap',\n    EnumMember = 'EnumMember',\n\n    // Literals\n    CommentLine = 'CommentLine',\n    CommentBlock = 'CommentBlock',\n    StringLiteral = 'StringLiteral',\n    IntegerLiteral = 'IntegerLiteral',\n    FloatLiteral = 'FloatLiteral',\n    HexLiteral = 'HexLiteral',\n    ExponentialLiteral = 'ExponentialLiteral',\n    BooleanLiteral = 'BooleanLiteral',\n    PropertyAssignment = 'PropertyAssignment',\n\n    // Tokens\n    LeftParenToken = 'LeftParenToken',\n    RightParenToken = 'RightParenToken',\n    LeftBraceToken = 'LeftBraceToken',\n    RightBraceToken = 'RightBraceToken',\n    LeftBracketToken = 'LeftBracketToken',\n    RightBracketToken = 'RightBracketToken',\n    CommaToken = 'CommaToken',\n    DotToken = 'DotToken',\n    MinusToken = 'MinusToken',\n    SemicolonToken = 'SemicolonToken',\n    ColonToken = 'ColonToken',\n    StarToken = 'StarToken',\n    EqualToken = 'EqualToken',\n    LessThanToken = 'LessThanToken',\n    GreaterThanToken = 'GreaterThanToken',\n\n    // Keywords\n    NamespaceKeyword = 'NamespaceKeyword',\n    IncludeKeyword = 'IncludeKeyword',\n    CppIncludeKeyword = 'CppIncludeKeyword',\n    ExceptionKeyword = 'ExceptionKeyword',\n    ServiceKeyword = 'ServiceKeyword',\n    ExtendsKeyword = 'ExtendsKeyword',\n    RequiredKeyword = 'RequiredKeyword',\n    OptionalKeyword = 'OptionalKeyword',\n    FalseKeyword = 'FalseKeyword',\n    TrueKeyword = 'TrueKeyword',\n    ConstKeyword = 'ConstKeyword',\n    DoubleKeyword = 'DoubleKeyword',\n    StructKeyword = 'StructKeyword',\n    TypedefKeyword = 'TypedefKeyword',\n    UnionKeyword = 'UnionKeyword',\n    StringKeyword = 'StringKeyword',\n    BinaryKeyword = 'BinaryKeyword',\n    BoolKeyword = 'BoolKeyword',\n    ByteKeyword = 'ByteKeyword',\n    EnumKeyword = 'EnumKeyword',\n    SenumKeyword = 'SenumKeyword',\n    ListKeyword = 'ListKeyword',\n    SetKeyword = 'SetKeyword',\n    MapKeyword = 'MapKeyword',\n    I8Keyword = 'I8Keyword',\n    I16Keyword = 'I16Keyword',\n    I32Keyword = 'I32Keyword',\n    I64Keyword = 'I64Keyword',\n    Int8Keyword = 'Int8Keyword',\n    Int16Keyword = 'Int16Keyword',\n    Int32Keyword = 'Int32Keyword',\n    Int64Keyword = 'Int64Keyword',\n    ThrowsKeyword = 'ThrowsKeyword',\n    VoidKeyword = 'VoidKeyword',\n    OnewayKeyword = 'OnewayKeyword',\n\n    // Other\n    Annotation = 'Annotation',\n    Annotations = 'Annotations',\n\n    EOF = 'EOF',\n}\n","import {\n  ThriftDocument,\n  SyntaxType,\n  Comment,\n  ServiceDefinition,\n  StructLike,\n  PrimarySyntax,\n  EnumDefinition\n} from './@creditkarma/thrift-parser';\n\nexport const collectCommentsAndPrimarySyntax = (\n  ast: ThriftDocument\n): {\n  comments: Comment[];\n  primarySyntaxNodes: PrimarySyntax[];\n} => {\n  const comments: Comment[] = [];\n  const primarySyntaxNodes: PrimarySyntax[] = [];\n  // 从这些内容里面获取comment用于重构\n  const primarySyntaxType = [\n    SyntaxType.IncludeDefinition,\n    SyntaxType.ServiceDefinition,\n    SyntaxType.FunctionDefinition,\n    SyntaxType.NamespaceDefinition,\n    SyntaxType.ConstDefinition,\n    SyntaxType.TypedefDefinition,\n    SyntaxType.EnumDefinition,\n    SyntaxType.EnumMember,\n    SyntaxType.StructDefinition,\n    SyntaxType.UnionDefinition,\n    SyntaxType.ExceptionDefinition,\n    SyntaxType.FieldDefinition\n  ];\n  const hasChildrenType = [\n    SyntaxType.ServiceDefinition,\n    SyntaxType.EnumDefinition,\n    SyntaxType.StructDefinition,\n    SyntaxType.UnionDefinition,\n    SyntaxType.ExceptionDefinition\n  ];\n  // 从单个元素中收集comments\n  const collectSingleComments = (item: PrimarySyntax): void => {\n    if (item.comments.length) {\n      comments.push(...item.comments);\n    }\n  };\n  ast.body.forEach(thriftStatement => {\n    const type = thriftStatement.type;\n    primarySyntaxNodes.push(thriftStatement);\n    if (primarySyntaxType.includes(type)) {\n      if (hasChildrenType.includes(type)) {\n        switch (type) {\n          case SyntaxType.ServiceDefinition:\n            (thriftStatement as ServiceDefinition).functions.forEach(item => {\n              // TODO: 考虑FunctionDefinition中包含的FieldDefinition的注释。。\n              /**\n               * 例如：\n               * service CollectService {\n               *     Collection Collect(\n               *         1:i32 req // 奇怪的注释，感觉不想允许它的存在\n               *     )  (method = 'GET',  uri = '/api/collect'),\n               * }\n               */\n              collectSingleComments(item);\n              primarySyntaxNodes.push(item);\n            });\n            break;\n          case SyntaxType.EnumDefinition:\n            (thriftStatement as EnumDefinition).members.forEach(item => {\n              collectSingleComments(item);\n              primarySyntaxNodes.push(item);\n            });\n            break;\n          case SyntaxType.StructDefinition:\n          case SyntaxType.UnionDefinition:\n          case SyntaxType.ExceptionDefinition:\n            (thriftStatement as StructLike).fields.forEach(item => {\n              collectSingleComments(item);\n              primarySyntaxNodes.push(item);\n            });\n            break;\n        }\n      }\n      collectSingleComments(thriftStatement);\n    }\n  });\n  return {\n    comments: comments.sort((a, b) => a.loc.start.index - b.loc.start.index),\n    // 有序之后做二分查找\n    primarySyntaxNodes: primarySyntaxNodes.sort(\n      (a, b) => a.loc.start.index - b.loc.start.index\n    )\n  };\n};\n\nexport const handleComments = (ast: ThriftDocument): ThriftDocument => {\n  const { comments, primarySyntaxNodes } = collectCommentsAndPrimarySyntax(ast);\n  // 先把所有的primarySyntaxNodes初始化\n  primarySyntaxNodes.forEach(node => {\n    node.commentsBefore = [];\n    node.commentsAfter = [];\n  });\n  // 配对O(n2) TODO: 优化到O(nlogn)，如果没有性能问题就不管了\n  // 规则：\n  // - line相同，比较index，comment.index > PrimarySyntax.index，\n  //    认为是PrimarySyntax的commentsBefore，comment.index < PrimarySyntax.index，认为是PrimarySyntax的commentsAfter\n  // - 多个line相同的取先出现的，即index小的\n  // - 没有line相同的，取comment.index > PrimarySyntax.index且argmin( PrimarySyntax.index)，\n  //    即最接近且在comment之后的PrimarySyntax，认为是PrimarySyntax的commentsBefore\n  comments.forEach(commemt => {\n    let targetNode: PrimarySyntax | undefined;\n    const commentEndIndex = commemt.loc.end.index;\n    targetNode = primarySyntaxNodes.find(\n      pNode => pNode.loc.end.line === commemt.loc.end.line\n    );\n    if (targetNode) {\n      if (targetNode.loc.start.index > commentEndIndex) {\n        targetNode.commentsBefore!.push(commemt);\n      } else {\n        targetNode.commentsAfter!.push(commemt);\n      }\n      return;\n    }\n    let i;\n    for (i = 0; i < primarySyntaxNodes.length; i++) {\n      const nodeStartIndex = primarySyntaxNodes[i].loc.start.index;\n      if (i === 0 && nodeStartIndex > commentEndIndex) {\n        targetNode = primarySyntaxNodes[0];\n        break;\n      }\n      // TODO: 处理位于idl末尾的comment\n      if (\n        nodeStartIndex > commentEndIndex &&\n        primarySyntaxNodes[i - 1].loc.start.index < nodeStartIndex\n      ) {\n        targetNode = primarySyntaxNodes[i];\n        break;\n      }\n    }\n\n    if (targetNode) {\n      targetNode.commentsBefore!.push(commemt);\n    }\n  });\n  // 上面用的是浅拷贝直接修改原数据\n  return ast;\n};\n","/* eslint-disable */\nimport {\n  parse,\n  ThriftDocument,\n  ThriftErrors,\n  SyntaxType,\n  ThriftStatement,\n  FunctionType,\n  FieldDefinition,\n  FunctionDefinition,\n  EnumDefinition,\n  ConstDefinition,\n  DoubleConstant,\n  IntConstant,\n  StringLiteral,\n} from \"./@creditkarma/thrift-parser\";\nimport {\n  RpcEntity,\n  CMDOptions,\n  InterfacePropertyEntity,\n  InterfaceEntity,\n  TypeDefEntity,\n  ServiceEntity,\n  FunctionEntity,\n  EnumEntity,\n  EnumEntityMember,\n  ConstantEntity,\n  ConstantEntityType,\n} from \"./interfaces\";\nimport { handleComments } from \"./handleComments\";\n// import * as fs from \"fs-extra\";\nimport { isUndefined } from \"../tools/utils\";\nimport chalk from \"chalk\";\n\nconst error = chalk.bgRed.white.bold;\n\nexport async function readCode(\n  filefullname: string,\n  options?: Partial<CMDOptions>, // TODO 添加option支持\n  includeMap?: { [key: string]: RpcEntity }\n): Promise<RpcEntity> {\n  // const source = await fs.readFile(filefullname);\n  const source = \"\";\n  return parser(filefullname, source.toString(), options, includeMap);\n}\n\nexport function parser(\n  filefullname: string,\n  source: string,\n  options?: Partial<CMDOptions>, // TODO 添加option支持\n  includeMap?: { [key: string]: RpcEntity }\n): RpcEntity {\n  const ast: ThriftDocument | ThriftErrors = parse(source, {\n    reservedWord: options?.reservedWord || \"error\",\n  });\n\n  if (!isThritDocument(ast)) {\n    alert(\"thrift格式不正确\");\n    throw new Error(\"thrift parser error:\" + filefullname);\n  }\n  handleComments(ast);\n  //   if (options && options.annotationConfigPath) {\n  //     if (fs.existsSync(options.annotationConfigPath)) {\n  //       try {\n  //         options.annotationConfig = JSON.parse(\n  //           fs.readFileSync(options.annotationConfigPath, \"utf8\")\n  //         );\n  //       } catch (e) {\n  //         console.error(e);\n  //       }\n  //     }\n  //   }\n\n  const rtn: RpcEntity = {\n    ns: \"\",\n    fileName: filefullname,\n    includes: [],\n    interfaces: [],\n    enums: [],\n    typeDefs: [],\n    services: [],\n    consts: [],\n  };\n\n  const namespaces: { [key: string]: string } = {};\n\n  ast.body.forEach((ts: ThriftStatement) => {\n    // namespace\n    if (ts.type === SyntaxType.NamespaceDefinition) {\n      // namespace 的处理逻辑，抓一个就来了\n      // TODO 优先考虑js的namespace，之后是go，再之后随便抓一个\n      namespaces[ts.scope.value] = ts.name.value;\n    }\n    // includes\n    if (ts.type === SyntaxType.IncludeDefinition) {\n      rtn.includes.push(ts.path.value);\n    }\n    // struct like: struct exception union --> interfaces\n    if (\n      ts.type === SyntaxType.StructDefinition ||\n      ts.type === SyntaxType.UnionDefinition ||\n      ts.type === SyntaxType.ExceptionDefinition\n    ) {\n      const name: string = ts.name.value;\n      const aInterface: InterfaceEntity = {\n        name,\n        properties: {},\n        loc: ts.loc,\n        comments: ts.comments,\n        commentsAfter: ts.commentsAfter,\n        commentsBefore: ts.commentsBefore,\n      };\n      // 添加属性\n      ts.fields.forEach((field: any) => {\n        const { entity: temp, name } = handleField(\n          field,\n          options,\n          ts.name.value\n        );\n        aInterface.properties[name] = temp;\n      });\n      rtn.interfaces.push(aInterface);\n    }\n\n    // typedef\n    if (ts.type === SyntaxType.TypedefDefinition) {\n      const aTypeDef: TypeDefEntity = {\n        type: \"\",\n        alias: \"\",\n        comments: ts.comments,\n        commentsAfter: ts.commentsAfter,\n        commentsBefore: ts.commentsBefore,\n        loc: ts.loc,\n      };\n      aTypeDef.alias = ts.name.value;\n      aTypeDef.type = getFieldTypeString(ts.definitionType, options, ts);\n      rtn.typeDefs.push(aTypeDef);\n    }\n\n    // service\n    if (ts.type === SyntaxType.ServiceDefinition) {\n      const aService: ServiceEntity = {\n        name: ts.name.value,\n        interfaces: {},\n        comments: ts.comments,\n        commentsAfter: ts.commentsAfter,\n        commentsBefore: ts.commentsBefore,\n        loc: ts.loc,\n      };\n      ts.functions.forEach((func) => {\n        aService.interfaces[func.name.value] = handleFunction(func, options);\n      });\n      rtn.services.push(aService);\n    }\n\n    // enum\n    if (ts.type === SyntaxType.EnumDefinition) {\n      rtn.enums.push(handleEnum(ts));\n    }\n\n    // const 考虑支持\n    if (ts.type === SyntaxType.ConstDefinition) {\n      const temp = handleConst(ts);\n      if (temp !== false) {\n        rtn.consts.push(temp);\n      }\n    }\n  });\n\n  const namespacesValues = Object.values(namespaces);\n  rtn.ns = namespaces.js || namespaces.go;\n  if (!rtn.ns && namespacesValues.length) {\n    rtn.ns = namespacesValues[0];\n  }\n\n  /* istanbul ignore if */\n  if (includeMap) {\n    includeMap[rtn.fileName] = rtn;\n  }\n  return rtn;\n}\n\nfunction isThritDocument(\n  ast: ThriftDocument | ThriftErrors\n): ast is ThriftDocument {\n  return ast.type === SyntaxType.ThriftDocument;\n}\n\n/**\n *\n * @param {ThriftDocument} ast thrift-parser输出的ast\n * @returns {RpcEntity} 返回rpc\n */\nexport function transformAst(ast: ThriftDocument): RpcEntity {\n  return {} as any;\n}\n\nfunction getFieldTypeString(\n  fieldType: FunctionType,\n  options: Partial<CMDOptions> = {},\n  field: Record<string, any> = {}\n): string {\n  const i64Type = \"Int64\";\n  const { mapType = \"Record\" } = options;\n  const ThriftType2JavascriptType: { [key: string]: string } = {\n    [SyntaxType.BoolKeyword]: \"boolean\",\n    [SyntaxType.ByteKeyword]: \"number\",\n    [SyntaxType.I8Keyword]: \"number\",\n    [SyntaxType.I16Keyword]: \"number\",\n    [SyntaxType.I32Keyword]: \"number\",\n    [SyntaxType.I64Keyword]: i64Type,\n    [SyntaxType.Int8Keyword]: \"number\",\n    [SyntaxType.Int16Keyword]: \"number\",\n    [SyntaxType.Int32Keyword]: \"number\",\n    [SyntaxType.Int64Keyword]: i64Type,\n    [SyntaxType.DoubleKeyword]: \"number\",\n    [SyntaxType.StringKeyword]: \"string\",\n    [SyntaxType.BinaryKeyword]: \"any\",\n    [SyntaxType.ListKeyword]: \"Array\",\n    [SyntaxType.MapKeyword]: \"Map\",\n    [SyntaxType.SetKeyword]: \"Set\",\n    // UPDATE 添加void\n    [SyntaxType.VoidKeyword]: \"void\",\n  };\n\n  if (options)\n    if (fieldType.type === SyntaxType.Identifier) {\n      return fieldType.value;\n    }\n  if (fieldType.type === SyntaxType.SetType) {\n    return `Set<${getFieldTypeString(\n      fieldType.valueType,\n      options,\n      fieldType\n    )}>`;\n  }\n  if (fieldType.type === SyntaxType.ListType) {\n    return `${getFieldTypeString(fieldType.valueType, options, fieldType)}[]`;\n  }\n  if (fieldType.type === SyntaxType.MapType) {\n    if (mapType === \"Record\") {\n      return `${mapType}<string, ${getFieldTypeString(\n        fieldType.valueType,\n        options,\n        fieldType\n      )}>`;\n    }\n    return `${mapType}<${getFieldTypeString(\n      fieldType.keyType,\n      options,\n      fieldType\n    )}, ${getFieldTypeString(fieldType.valueType, options, fieldType)}>`;\n  }\n  if (fieldType.type === SyntaxType.I64Keyword) {\n    console.log(\n      error(`WARN: 存在i64类型字段: ${field?.name?.value}，该类型定义可能错误`)\n    );\n  }\n  return ThriftType2JavascriptType[fieldType.type];\n}\n\ninterface IhandleField {\n  entity: InterfacePropertyEntity;\n  name: string;\n}\n\nfunction handleField(\n  field: FieldDefinition,\n  options: Partial<CMDOptions> = {},\n  structName = \"\"\n): IhandleField {\n  let name = field.name.value;\n  const commentsBefore = field.commentsBefore || [];\n  // 需要处理typedef\n  const type = getFieldTypeString(field.fieldType, options, field);\n  const index = field.fieldID ? field.fieldID.value : 0;\n  // 考虑多种type数据的default value StringLiteral | IntConstant | DoubleConstant | BooleanLiteral | ConstMap | ConstList | Identifier\n  let defaultValue: string | undefined;\n  if (field.defaultValue !== null) {\n    switch (field.defaultValue.type) {\n      case SyntaxType.StringLiteral:\n        defaultValue = field.defaultValue.value;\n        break;\n      case SyntaxType.IntConstant:\n        defaultValue = field.defaultValue.value.value;\n        break;\n      case SyntaxType.DoubleConstant:\n        defaultValue = field.defaultValue.value.value;\n        break;\n      case SyntaxType.BooleanLiteral:\n        defaultValue = String(field.defaultValue.value);\n        break;\n      case SyntaxType.ConstMap:\n        // 简单的处理\n        defaultValue = \"Map\";\n        break;\n      case SyntaxType.ConstList:\n        // 简单的处理2\n        defaultValue = \"List\";\n        break;\n      case SyntaxType.Identifier:\n        defaultValue = field.defaultValue.value;\n        break;\n    }\n  }\n\n  if (options.useTag) {\n    const annotations = field.annotations;\n    const tagValueReg = /json:\"([\\w_\\d]+).*\"/;\n    const tagNameReg = /(\\w+).tag/;\n    if (annotations) {\n      const nameTag = annotations.annotations.find(\n        (annotation: { name: { value: string } }) => {\n          let match;\n          if ((match = tagNameReg.exec(annotation.name.value))) {\n            return match[1] === options.useTag;\n          }\n          return false;\n        }\n      );\n      if (nameTag) {\n        const match = tagValueReg.exec(\n          nameTag.value ? nameTag.value.value : \"\"\n        );\n        if (match) {\n          name = match[1];\n        }\n      }\n    }\n  }\n  // annotation config 优先级高于useTag\n  if (options && options.annotationConfig) {\n    const { fieldComment, fieldKey } = options.annotationConfig;\n    if (\n      field.annotations &&\n      Array.isArray(field.annotations.annotations) &&\n      (Array.isArray(fieldComment) || fieldKey)\n    ) {\n      let comment = \"\";\n      field.annotations.annotations.forEach((annotation) => {\n        if (Array.isArray(fieldComment)) {\n          if (fieldComment.indexOf(annotation.name.value) > -1) {\n            comment += `@${annotation.name.value}:${\n              annotation!.value!.value\n            }    `;\n          }\n        }\n        let fieldKeyArr: string[];\n        // 支持fieldKey是个数组\n        if (Array.isArray(fieldKey)) {\n          fieldKeyArr = fieldKey;\n        } else {\n          fieldKeyArr = [fieldKey || \"___some_error_value___\"];\n        }\n        // 如果存在多个annotation命中，后面的覆盖前面的\n        if (fieldKeyArr.length) {\n          if (fieldKeyArr.indexOf(annotation.name.value) > -1) {\n            name = annotation!.value!.value;\n          }\n        }\n      });\n      commentsBefore.push({\n        type: SyntaxType.CommentLine,\n        value: comment,\n        loc: field.loc,\n      });\n    }\n  }\n\n  let optional = false;\n  if (field.requiredness === \"required\") {\n    optional = false;\n  } else if (field.requiredness === \"optional\") {\n    optional = true;\n  } else {\n    const isRes = /response/i.test(structName);\n    const isReq = /request/i.test(structName);\n    const useStrict = options.useStrictMode;\n    const useStrictReq = options.strictReq;\n    const hasDefault = !isUndefined(defaultValue);\n\n    if (useStrict) {\n      optional = true;\n    }\n    if (isReq && useStrictReq) {\n      optional = true;\n    }\n    if (isReq && hasDefault) {\n      optional = true;\n    }\n    if (!isRes && !isReq && hasDefault) {\n      optional = true;\n    }\n  }\n\n  if (!isUndefined(defaultValue)) {\n    let value = defaultValue;\n    if (defaultValue === \"\") {\n      value = '\"\"';\n    }\n\n    commentsBefore.push({\n      type: SyntaxType.CommentLine,\n      value: `@default: ${value}`,\n      loc: field.loc,\n    });\n  } else {\n    defaultValue = \"\";\n  }\n\n  return {\n    entity: {\n      type,\n      index,\n      optional,\n      defaultValue,\n      comments: field.comments,\n      commentsBefore,\n      commentsAfter: field.commentsAfter,\n      loc: field.loc,\n    },\n    name,\n  };\n}\n\n/*\n  returnType: string;\n  inputParams: Array<{\n    type: string;\n    index: number;\n    name: string;\n  }>;\n  comment: string;\n */\nfunction handleFunction(\n  func: FunctionDefinition,\n  options?: Partial<CMDOptions> | undefined\n): FunctionEntity {\n  const returnType = getFieldTypeString(func.returnType, options, func);\n  const inputParams = func.fields.map((field: any) => {\n    const { entity: temp, name } = handleField(field, options);\n    return {\n      type: temp.type,\n      index: temp.index,\n      name,\n    };\n  });\n  let comment = \"\";\n  if (options && options.annotationConfig) {\n    // 根据annotation生成config\n    const { functionMethod, functionUri } = options.annotationConfig;\n    if (functionMethod || functionUri) {\n      if (func.annotations && Array.isArray(func.annotations.annotations)) {\n        func.annotations.annotations.forEach((annotation) => {\n          if (functionMethod) {\n            if (annotation.name.value === functionMethod) {\n              comment += `@method: ${annotation!.value!.value}    `;\n            }\n          }\n          if (functionUri) {\n            if (annotation.name.value === functionUri) {\n              comment += `@uri: ${annotation!.value!.value}    `;\n            }\n          }\n        });\n      }\n    }\n    const { fieldComment } = options.annotationConfig;\n    if (\n      func.annotations &&\n      Array.isArray(func.annotations.annotations) &&\n      Array.isArray(fieldComment)\n    ) {\n      func.annotations.annotations.forEach((annotation) => {\n        if (Array.isArray(fieldComment)) {\n          if (fieldComment.indexOf(annotation.name.value) > -1) {\n            comment += `@${annotation.name.value}: ${\n              annotation!.value!.value\n            }    `;\n          }\n        }\n      });\n    }\n  }\n  const commentsBefore = func.commentsBefore || [];\n  if (comment) {\n    commentsBefore.push({\n      loc: func.loc,\n      value: comment,\n      type: SyntaxType.CommentLine,\n    });\n  }\n  return {\n    returnType,\n    inputParams,\n    comments: [],\n    loc: func.loc,\n    commentsBefore,\n    commentsAfter: func.commentsAfter,\n  };\n}\n\nfunction handleConst(\n  c: ConstDefinition,\n  options?: CMDOptions\n): ConstantEntity | false {\n  let cType;\n  let value;\n  const constType = c.fieldType.type;\n  if (\n    c.name.value === \"liuqi\" &&\n    (c.initializer as IntConstant).value.value === \"1995\"\n  ) {\n    return false;\n  }\n  if (\n    constType === SyntaxType.DoubleKeyword ||\n    constType === SyntaxType.I8Keyword ||\n    constType === SyntaxType.I16Keyword ||\n    constType === SyntaxType.I32Keyword ||\n    constType === SyntaxType.I64Keyword ||\n    constType === SyntaxType.Int8Keyword ||\n    constType === SyntaxType.Int16Keyword ||\n    constType === SyntaxType.Int32Keyword ||\n    constType === SyntaxType.Int64Keyword ||\n    constType === SyntaxType.ByteKeyword\n  ) {\n    cType = constType;\n    value = (c.initializer as IntConstant | DoubleConstant).value.value;\n  } else if (constType === SyntaxType.StringKeyword) {\n    cType = constType;\n    value = (c.initializer as StringLiteral).value;\n  } else {\n    return false;\n  }\n  let typeString = getFieldTypeString(c.fieldType, options, c);\n  if (typeString === \"Int64\") {\n    typeString = \"string\";\n  }\n\n  const name = c.name.value;\n  return {\n    type: cType as ConstantEntityType,\n    value,\n    name,\n    comments: c.comments,\n    loc: c.loc,\n    typeString,\n  };\n}\n\nfunction handleEnum(e: EnumDefinition, options?: CMDOptions): EnumEntity {\n  const name = e.name.value;\n  const properties: {\n    [key: string]: EnumEntityMember;\n  } = {};\n  let currentValue = 0;\n  e.members.forEach((member) => {\n    /**\n     * https://wiki.apache.org/thrift/Tutorial\n     * You can define enums, which are just 32 bit integers. Values are optional\n     * and start at 1 if not supplied, C style again.\n     *              ^ ThriftIDL page says \"If no constant value is supplied,\n     *   the value is either 0 for the first element, or one greater than the\n     *   preceding value for any subsequent element\" so I'm guessing that's a bug.\n     *   PS: http://enel.ucalgary.ca/People/Norman/enel315_winter1997/enum_types/ states that if values are not supplied, they start at 0 and not 1.\n     */\n    let value: number;\n    if (member.initializer) {\n      value = parseInt(member.initializer.value.value, 10);\n    } else {\n      value = currentValue++;\n    }\n    properties[member.name.value] = {\n      value,\n      loc: member.loc,\n      comments: member.comments,\n      commentsBefore: member.commentsBefore,\n      commentsAfter: member.commentsAfter,\n    };\n  });\n  return {\n    name,\n    properties,\n    loc: e.loc,\n    comments: e.comments,\n    commentsBefore: e.commentsBefore,\n    commentsAfter: e.commentsAfter,\n  };\n}\n","/* eslint-disable */\nimport {\n  SyntaxType,\n  Comment,\n  CommentLine,\n  CommentBlock,\n  TextLocation,\n} from \"./@creditkarma/thrift-parser\";\n// import * as path from \"path\";\n// import * as fs from \"fs-extra\";\nimport { RpcEntity, CMDOptions } from \"./interfaces\";\nimport { prettier } from \"../tools/format\";\n\n/* istanbul ignore next */\nexport async function print(\n  // export function print(\n  entity: RpcEntity | undefined\n  // options: CMDOptions,\n  // includeMap: { [key: string]: RpcEntity }\n): Promise<string> {\n  // ): string {\n  if (!entity || !entity.ns) {\n    // 过滤掉没有 namespace 的\n    return \"\";\n  }\n  // const ns = options.autoNamespace\n  //   ? printNamespace(entity, options.root)\n  //   : entity.ns;\n  const now = new Date();\n  const timeString = `${now.getFullYear()}-${\n    now.getMonth() + 1\n  }-${now.getDate()} ${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`;\n  const content = `// generate${` at ${timeString}`}\\n\n/*******************************************************\n * !!! 警告：此代码为自动生成，请勿手动修改 !!!\n * !!! 任何手动修改将在下次生成时被覆盖 !!!\n *******************************************************/\\n\n/**\n* @deprecated 强烈不建议使用i64类型，有些语言解析json里面 超过范围 [-(2^53)+1, (2^53)-1] 的数字会出现解析错误的情况，建议使用i32，如果可能超出i32的表示范围，建议使用string类型\n*/\ntype Int64 = string\\n\n${printConsts(entity)}\n${printEnums(entity)}\n${printInterfaces(entity)}\n${printTypeDefs(entity)}\n${printServices(entity)}\n`;\n\n  return content;\n  // const relativePath: path.ParsedPath = path.parse(\n  //   path.relative(options.root, entity.fileName)\n  // );\n  // const target = path.resolve(\n  //   options.tsRoot,\n  //   relativePath.dir,\n  //   `${relativePath.name}.ts`\n  // );\n\n  // await fs.ensureFile(target);\n  // return fs.writeFile(\n  //   target,\n  //   fixIncludeNamespace(content, entity, includeMap),\n  //   \"utf8\"\n  // );\n}\n\n/**\n * 根据到 root 的相对路径生成 namespace\n *\n * @param {RpcEntity} entity\n * @param {string} root\n * @returns {string} namespace\n */\n// function printNamespace(entity: RpcEntity, root: string): string {\n//   const relativePath: path.ParsedPath = path.parse(\n//     path.relative(root, entity.fileName)\n//   );\n//   const ns = relativePath.dir.replace(new RegExp(`\\\\${path.sep}`, \"g\"), \".\");\n//   /* istanbul ignore if */\n//   if (ns.indexOf(\".\") === 0) {\n//     throw new Error(\"ns error\");\n//   }\n\n//   return ns;\n// }\n\n/**\n * 输出 enums\n *\n * @export\n * @param {RpcEntity} entity thrift entity\n * @returns {string}\n */\nexport function printEnums(entity: RpcEntity): string {\n  /* istanbul ignore if */\n  if (!entity.enums || entity.enums.length === 0) {\n    return \"\";\n  }\n\n  let rtn: string = \"\";\n  entity.enums.forEach((datum, _i) => {\n    rtn += printComments(datum.commentsBefore);\n    rtn += `export const enum ${datum.name} {\n    ${Object.keys(datum.properties)\n      .map((key, i, arr) => {\n        const property = datum.properties[key];\n        const cb = printComments(property.commentsBefore); // comments before\n        const ca = printComments(property.commentsAfter, property.loc); // comments after\n        const temp = `${cb}${key} = ${property.value}${\n          arr.length - 1 === i ? \"\" : \",\"\n        }`;\n        return attachCommentAfterToAbovePosition(temp, ca);\n      })\n      .join(\"\\n    \")}\n}    ${printComments(datum.commentsAfter, datum.loc)}\n\n`;\n  });\n  return rtn;\n}\n\n/**\n * 输出 consts\n *\n * @export\n * @param {RpcEntity} entity thrift entity\n * @returns {string}\n */\nexport function printConsts(entity: RpcEntity): string {\n  /* istanbul ignore if */\n  if (!entity.consts || entity.consts.length === 0) {\n    return \"\";\n  }\n\n  let rtn: string = \"\";\n  entity.consts.forEach((datum, _i) => {\n    rtn += printComments(datum.commentsBefore);\n    if (\n      datum.type === SyntaxType.I64Keyword ||\n      datum.type === SyntaxType.StringKeyword\n    ) {\n      rtn += `export const ${datum.name} = '${datum.value}'\\n`;\n    } else {\n      rtn += `export const ${datum.name} = ${datum.value}\\n`;\n    }\n  });\n  return rtn;\n}\n\n/**\n * 输出 interfaces\n *\n * @export\n * @param {Pick<RpcEntity, 'interfaces'>} entity thrift entity\n * @returns {string}\n */\nexport function printInterfaces(\n  entity: Pick<RpcEntity, \"interfaces\">\n): Promise<string> | string {\n  if (!entity.interfaces || entity.interfaces.length === 0) {\n    return \"\";\n  }\n\n  let rtn = \"\";\n  entity.interfaces.forEach((datum, _i) => {\n    rtn += printComments(datum.commentsBefore);\n    rtn += `export interface ${datum.name} {\n    ${Object.keys(datum.properties)\n      .map((key, i, arr) => {\n        const property = datum.properties[key];\n        const cb = printComments(property.commentsBefore); // comments before\n        const ca = printComments(property.commentsAfter, property.loc); // comments after\n        let temp = `${key}${property.optional ? \"?\" : \"\"}: ${property.type};`;\n        if (ca) {\n          temp = attachCommentAfterToAbovePosition(temp, ca);\n        }\n        if (cb) {\n          temp = cb.trim() + \"\\n\" + temp.trim();\n        }\n        return temp;\n      })\n      .join(\"\\n    \")}\n}    ${printComments(datum.commentsAfter, datum.loc)}\n\n`;\n  });\n\n  // return prettier(rtn);\n  return rtn;\n}\n\n/**\n * 输出 typedef\n *\n * @export\n * @param {RpcEntity} entity\n * @returns {string}\n */\nexport function printTypeDefs(entity: RpcEntity): string {\n  if (entity.typeDefs.length === 0) {\n    return \"\";\n  }\n\n  let rtn = \"\";\n  entity.typeDefs.forEach((datum) => {\n    rtn += printComments(datum.commentsBefore);\n    rtn += `  export type ${datum.alias} = ${datum.type};${printComments(\n      datum.commentsAfter,\n      datum.loc\n    )}\\n`;\n  });\n  return rtn + \"\\n\";\n}\n\n/**\n * 以 12 个半角字符宽度对齐行注释\n *\n * @param {string} str\n * @param {string} comment\n * @returns {string}\n */\nfunction attachComment(str: string, comment: string): string {\n  const c = comment;\n\n  if (!c) {\n    return str;\n  }\n  const len = str.length + 1;\n  const len2 = Math.ceil(len / 12) * 12;\n  return `${str.padEnd(len2, \" \")} ${c}`;\n}\n\nfunction attachCommentAfterToAbovePosition(\n  str: string,\n  comment: string\n): string {\n  return comment.trim() + \"\\n    \" + str;\n}\n\n/**\n * 这个函数用来修复类型是通过 import 导入的名称\n *\n * @export\n * @param {string} content\n * @param {Pick<RpcEntity, 'fileName' | 'includes'>} entity\n * @param {{ [absolutFilepath: string]: RpcEntity }} includeMap\n * @returns {string}\n */\n// export function fixIncludeNamespace(\n//   content: string,\n//   entity: Partial<RpcEntity> & Pick<RpcEntity, \"fileName\" | \"includes\">,\n//   includeMap: {\n//     [absolutFilepath: string]: Partial<RpcEntity> & Pick<RpcEntity, \"ns\">;\n//   }\n// ): string {\n//   let result = content;\n//   const currentFile = path.parse(entity.fileName);\n//   entity.includes.forEach((include) => {\n//     // 获取所有 include 语句所对应的 entity\n//     const includeKey = path.resolve(currentFile.dir, include);\n//     const includeEntity = includeMap[includeKey];\n\n//     if (!includeEntity) {\n//       return;\n//     }\n\n//     const shouldBeNS = includeEntity.ns; // 需要替换成的 namespace\n//     const shouldReplaceNS = path.parse(include).name; // 如果文件中有用到 filename 作为 namespace\n\n//     result = result.replace(\n//       new RegExp(\n//         `([^\\\\w\\\\.])((?<!__SEGMENT__.*)${shouldReplaceNS}\\\\.|${shouldReplaceNS}(?!.*__SEGMENT__)\\\\.)`,\n//         \"g\"\n//       ),\n//       `__SEGMENT__$1${shouldBeNS}__SEGMENT__.`\n//     );\n//   });\n\n//   // return result.replace(new RegExp(`__SEGMENT__`, 'g'), '');\n//   return (\n//     \"// prettier-ignore\\n\" +\n//     prettier(result.replace(new RegExp(\"__SEGMENT__\", \"g\"), \"\"))\n//   );\n// }\n\n/**\n * 打印 service\n *\n * @export\n * @param {RpcEntity} entity\n * @param {boolean} [isGenerateRPC=false] 如果是用来生成 RPC 的打印，需要加上 namespace\n * @returns\n */\nexport function printServices(\n  entity: RpcEntity,\n  isGenerateRPC: boolean = false\n) {\n  const serviceEntity = entity.services;\n  const keyInNs = [\n    ...entity.enums.map((d) => d.name),\n    ...entity.typeDefs.map((d) => d.alias),\n    ...entity.interfaces.map((d) => d.name),\n  ];\n  return serviceEntity.reduce((rtn, cur) => {\n    rtn += printComments(cur.commentsBefore);\n    rtn += `export interface Service${cur.name} {\n${Object.keys(cur.interfaces)\n  .map((key) => {\n    const i = cur.interfaces[key];\n    let sortTmp: any[] = [];\n    i.inputParams.forEach((d) => (sortTmp[d.index] = d));\n    sortTmp = sortTmp.filter((d) => !!d);\n    const inputParamsStr = (sortTmp as (typeof i)[\"inputParams\"])\n      .map((d) => {\n        const type =\n          isGenerateRPC && keyInNs.indexOf(d.type) !== -1\n            ? `${entity.ns}.${d.type}`\n            : d.type;\n        return `${d.name}: ${type}`;\n      })\n      .join(\", \");\n    const returnType =\n      isGenerateRPC && keyInNs.indexOf(i.returnType) !== -1\n        ? `${entity.ns}.${i.returnType}`\n        : i.returnType;\n    const cb = printComments(i.commentsBefore); // comments before\n    const ca = printComments(i.commentsAfter, i.loc); // comments after\n    let rtn = \"\";\n    if (cb.trim()) {\n      rtn += `    ${cb.trim()}\\n`;\n    }\n    if (ca.trim()) {\n      rtn += `    ${ca.trim()}\\n`;\n    }\n    rtn += `    ${key}(${inputParamsStr}): Promise<${returnType}>;`;\n    return rtn;\n  })\n  .join(\"\\n\")}\n}\n\n`;\n    return rtn;\n  }, \"\");\n}\n\n// export function printCollectionRpc(\n//   entity: RpcEntity,\n//   includeMap: {\n//     [absolutFilepath: string]: Partial<RpcEntity> & Pick<RpcEntity, \"ns\">;\n//   }\n// ): string | null {\n//   if (!entity.services.length) {\n//     return null;\n//   }\n//   const servicesCodes = printServices(entity, true);\n//   const rtn = fixIncludeNamespace(servicesCodes, entity, includeMap);\n//   return rtn;\n// }\n\nexport function printCommentLine(comment: CommentLine): string {\n  if (!comment.value) {\n    return \"\";\n  }\n  return `/** ${comment.value.replace(/\\*\\/+/g, \"\")} */`;\n}\n\nexport function printCommentBlock(comment: CommentBlock): string {\n  if (!comment.value.length) {\n    return \"\";\n  }\n  return `/*\\n* ${comment.value.join(\"\\n* \")}\\n*/`;\n}\n\n/**\n * @description 打印注释，如果是PrimarySyntax之前的注释，直接换行打印，如果是之后的注释\n *                传入PrimarySyntax的loc，判断是否打印在同一行\n *\n * @param comments 需要打印的comments\n * @param loc comments所属的PrimarySyntax的位置\n */\nexport function printComments(\n  comments: Comment[] = [],\n  loc?: TextLocation\n): string {\n  let res = \"\";\n  comments.forEach((comment, idx) => {\n    const sameLine =\n      loc &&\n      comment.loc.start.line === comment.loc.end.line &&\n      comment.loc.start.line === loc.end.line;\n    const lastOne = idx === comments.length - 1;\n    if (sameLine) {\n      if (comment.type === SyntaxType.CommentLine) {\n        res = printCommentLine(comment) + \"\\n\" + res;\n        if (!lastOne) {\n          res += \"    \";\n        }\n      }\n      if (comment.type === SyntaxType.CommentBlock) {\n        res += printCommentBlock(comment);\n        if (!lastOne) {\n          res += \"    \";\n        }\n      }\n    } else {\n      if (comment.type === SyntaxType.CommentLine) {\n        res = printCommentLine(comment) + \"\\n\" + res;\n        // 注释下面不要换行\n        // res += '\\n'\n      }\n      if (comment.type === SyntaxType.CommentBlock) {\n        res += printCommentBlock(comment);\n        // 注释下面不要换行\n        res += '\\n'\n      }\n    }\n  });\n  return res;\n}\n\n/**\n * @description 获取includeMap中的enum值\n */\nexport function printEnumsObject(includeMap: { [key: string]: RpcEntity }): {\n  [key: string]: number | string;\n} {\n  const res: { [key: string]: number | string } = {};\n  Object.keys(includeMap).forEach((key) => {\n    const rtn = includeMap[key];\n    if (rtn.ns) {\n      const namespace = rtn.ns;\n      const enums = rtn.enums;\n      // 在非--new的模式下，const为undefined\n      const consts = rtn.consts || [];\n      enums.forEach((e) => {\n        Object.keys(e.properties).forEach((eKey) => {\n          res[`${namespace}.${e.name}.${eKey}`] = e.properties[eKey].value;\n        });\n      });\n      consts.forEach((c) => {\n        let parsedValue: number | string;\n        if (\n          c.type === SyntaxType.ByteKeyword ||\n          c.type === SyntaxType.I8Keyword ||\n          c.type === SyntaxType.I16Keyword ||\n          c.type === SyntaxType.I32Keyword ||\n          c.type === SyntaxType.Int8Keyword ||\n          c.type === SyntaxType.Int16Keyword ||\n          c.type === SyntaxType.Int32Keyword\n        ) {\n          parsedValue = parseInt(c.value);\n        } else if (c.type === SyntaxType.DoubleKeyword) {\n          parsedValue = parseFloat(c.value);\n        } else {\n          parsedValue = c.value;\n        }\n        res[`${namespace}.${c.name}`] = parsedValue;\n      });\n    }\n  });\n  const sortedRes = Object.keys(res)\n    .sort()\n    .reduce(\n      (pre, cur) => {\n        pre[cur] = res[cur];\n        return pre;\n      },\n      {} as typeof res\n    );\n  return sortedRes;\n}\n","/* eslint-disable */\n// import * as fs from \"fs-extra\";\n\nexport function isUndefined(v: any): v is undefined {\n  return typeof v === \"undefined\";\n}\n\n// export function replaceTsHelperInt64(filePath: string) {\n//   const strToReplace = `declare var Int64: {\n//     prototype: Int64;\n//     new (): Int64;\n// };\n// interface Int64 {\n//     toString(): string;\n// }\n// declare type ReqNumber = number | string | Int64;\n// declare type RespNumber = Int64;\n// declare type WrapperReqNumber<T> = Int64 extends T ? ReqNumber : T extends number[] ? ReqNumber[] : T;\n// declare type WrapperRespNumber<T> = T extends number ? RespNumber : T extends number[] ? RespNumber[] : T;`;\n//   const newStr = `declare type Int64 = string;\n// declare type ReqNumber = number | string | Int64;\n// declare type RespNumber = Int64;\n// declare type WrapperReqNumber<T> = T;\n// declare type WrapperRespNumber<T> = T;`;\n//   fs.writeFileSync(\n//     filePath,\n//     fs.readFileSync(filePath).toString().replace(strToReplace, newStr)\n//   );\n// }\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AAsBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrHA;AAoCA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AACA;AAEA;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/QA;AACA;;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;;;;;;;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC7GA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClFA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACxFA;AAyCA;AAoBA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAKA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAKA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAEA;AAEA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAKA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAKA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AAIA;AACA;AAKA;AACA;AAKA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AAOA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AAKA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtyCA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAMA;AAEA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAOA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;;;AAGA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzIA;;;AAAA;AAGA;AAEA;;;;;AAOA;;;;;;;;;;;AAYA;;;;;AAMA;;;;;;AAOA;;;;;;;AASA;;;;;;;;;;AAWA;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA;;;;AA1GA;AA+GA;;;;;;;;;;;;;;;;;;;;;;AC1bA;AAUA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AClJA;AACA;AA4BA;AACA;AACA;AACA;AAEA;AAEA;AAAA;;AAAA;AAAA;AAKA;AACA;AACA;AACA;AARA;;AAUA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;;;;AAIA;AAEA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAKA;AACA;AAEA;AADA;AAGA;AACA;AACA;AAOA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;;;;;;;;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7kBA;AACA;AAYA;AAGA;AAFA;;AAAA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAlDA;;AAoDA;;;;;;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AAKA;AACA;AACA;AAEA;;;;;;AAMA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AAEA;;;;;;AAMA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;;;;;;AAMA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;;;;;;;;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AAEA;AAGA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;ACtdA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}