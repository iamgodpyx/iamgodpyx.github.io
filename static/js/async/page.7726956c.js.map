{"version":3,"file":"static/js/async/page.7726956c.js","sources":["webpack://thrift-to-ts-online/./src/lib/thriftNew/@creditkarma/thrift-parser/types.ts","webpack://thrift-to-ts-online/./src/lib/thriftNew/@creditkarma/thrift-parser/debugger.ts","webpack://thrift-to-ts-online/./src/lib/thriftNew/@creditkarma/thrift-parser/factory.ts","webpack://thrift-to-ts-online/./src/lib/thriftNew/@creditkarma/thrift-parser/keywords.ts","webpack://thrift-to-ts-online/./src/lib/thriftNew/@creditkarma/thrift-parser/parser.ts","webpack://thrift-to-ts-online/./src/lib/thriftNew/@creditkarma/thrift-parser/scanner.ts","webpack://thrift-to-ts-online/./src/lib/thriftNew/@creditkarma/thrift-parser/index.ts","webpack://thrift-to-ts-online/./src/lib/thriftNew/handleComments.ts","webpack://thrift-to-ts-online/./src/lib/thriftNew/index.ts","webpack://thrift-to-ts-online/./src/lib/tools/utils.ts","webpack://thrift-to-ts-online/./src/lib/thriftNew/print.ts","webpack://thrift-to-ts-online/./src/routes/page.tsx","webpack://thrift-to-ts-online/./src/lib/thriftNew/@creditkarma/thrift-parser/organizer.ts"],"sourcesContent":["export interface ThriftError {\n    type: ErrorType\n    message: string\n    loc: TextLocation\n}\n\nexport interface ParseError extends ThriftError {\n    type: ErrorType.ParseError\n}\n\nexport interface ScanError extends ThriftError {\n    type: ErrorType.ScanError\n}\n\nexport interface Node {\n    type: SyntaxType\n}\n\nexport interface SyntaxNode extends Node {\n    loc: TextLocation\n}\n\nexport interface StructLike {\n    name: Identifier\n    fields: Array<FieldDefinition>\n    annotations?: Annotations\n    comments: Array<Comment>\n    loc: TextLocation\n}\n\nexport interface TextLocation {\n    start: TextPosition\n    end: TextPosition\n}\n\nexport interface TextPosition {\n    line: number\n    column: number\n    index: number\n}\n\nexport interface Token extends SyntaxNode {\n    text: string\n}\n\nexport interface ThriftDocument extends Node {\n    type: SyntaxType.ThriftDocument\n    body: Array<ThriftStatement>\n    tokens?: Array<Token>\n}\n\nexport interface ThriftErrors {\n    type: SyntaxType.ThriftErrors\n    errors: Array<ThriftError>\n}\n\nexport type ThriftStatement =\n    | NamespaceDefinition\n    | IncludeDefinition\n    | CppIncludeDefinition\n    | ConstDefinition\n    | StructDefinition\n    | EnumDefinition\n    | ExceptionDefinition\n    | UnionDefinition\n    | TypedefDefinition\n    | ServiceDefinition\n\nexport type CommentType = SyntaxType.CommentLine | SyntaxType.CommentBlock\n\nexport type Comment = CommentLine | CommentBlock\n\nexport interface CommentLine extends SyntaxNode {\n    type: SyntaxType.CommentLine\n    value: string\n}\n\nexport interface CommentBlock extends SyntaxNode {\n    type: SyntaxType.CommentBlock\n    value: Array<string>\n}\n\nexport interface Annotations extends SyntaxNode {\n    annotations: Array<Annotation>\n}\n\nexport interface Annotation extends SyntaxNode {\n    name: Identifier\n    value?: StringLiteral\n}\n\nexport interface PrimarySyntax extends SyntaxNode {\n    comments: Array<Comment>\n    commentsBefore?: Array<Comment>\n    commentsAfter?: Array<Comment>\n}\n\nexport type FieldType = BaseType | ContainerType | Identifier\n\nexport type FunctionType = FieldType | VoidType\n\nexport type KeywordType =\n    | SyntaxType.StringKeyword\n    | SyntaxType.DoubleKeyword\n    | SyntaxType.BoolKeyword\n    | SyntaxType.I8Keyword\n    | SyntaxType.I16Keyword\n    | SyntaxType.I32Keyword\n    | SyntaxType.I64Keyword\n    | SyntaxType.Int8Keyword\n    | SyntaxType.Int16Keyword\n    | SyntaxType.Int32Keyword\n    | SyntaxType.Int64Keyword\n    | SyntaxType.BinaryKeyword\n    | SyntaxType.ByteKeyword\n\nexport interface VoidType extends SyntaxNode {\n    type: SyntaxType.VoidKeyword\n}\n\nexport type ContainerType = SetType | MapType | ListType\n\nexport interface BaseType extends SyntaxNode {\n    type: KeywordType\n    annotations?: Annotations\n}\n\nexport interface SetType extends SyntaxNode {\n    type: SyntaxType.SetType\n    valueType: FieldType\n    annotations?: Annotations\n}\n\nexport interface ListType extends SyntaxNode {\n    type: SyntaxType.ListType\n    valueType: FieldType\n    annotations?: Annotations\n}\n\nexport interface MapType extends SyntaxNode {\n    type: SyntaxType.MapType\n    keyType: FieldType\n    valueType: FieldType\n    annotations?: Annotations\n}\n\nexport type ConstValue =\n    | StringLiteral\n    | IntConstant\n    | DoubleConstant\n    | BooleanLiteral\n    | ConstMap\n    | ConstList\n    | Identifier\n\nexport interface NamespaceDefinition extends PrimarySyntax {\n    type: SyntaxType.NamespaceDefinition\n    scope: Identifier\n    name: Identifier\n}\n\nexport interface ConstDefinition extends PrimarySyntax {\n    type: SyntaxType.ConstDefinition\n    name: Identifier\n    fieldType: FieldType\n    initializer: ConstValue\n    annotations?: Annotations\n}\n\nexport type FieldRequired = 'required' | 'optional'\n\nexport interface IncludeDefinition extends PrimarySyntax {\n    type: SyntaxType.IncludeDefinition\n    path: StringLiteral\n}\n\nexport interface CppIncludeDefinition extends PrimarySyntax {\n    type: SyntaxType.CppIncludeDefinition\n    path: StringLiteral\n}\n\nexport interface InterfaceWithFields extends PrimarySyntax {\n    name: Identifier\n    fields: Array<FieldDefinition>\n    annotations?: Annotations\n}\n\nexport interface StructDefinition extends InterfaceWithFields {\n    type: SyntaxType.StructDefinition\n}\n\nexport interface UnionDefinition extends InterfaceWithFields {\n    type: SyntaxType.UnionDefinition\n}\n\nexport interface ExceptionDefinition extends InterfaceWithFields {\n    type: SyntaxType.ExceptionDefinition\n}\n\nexport interface FieldDefinition extends PrimarySyntax {\n    type: SyntaxType.FieldDefinition\n    name: Identifier\n    fieldID: FieldID | null\n    fieldType: FunctionType\n    requiredness: FieldRequired | null\n    defaultValue: ConstValue | null\n    annotations?: Annotations\n}\n\nexport interface FieldID extends SyntaxNode {\n    type: SyntaxType.FieldID\n    value: number\n}\n\nexport interface EnumDefinition extends PrimarySyntax {\n    type: SyntaxType.EnumDefinition\n    name: Identifier\n    members: Array<EnumMember>\n    annotations?: Annotations\n}\n\nexport interface EnumMember extends PrimarySyntax {\n    type: SyntaxType.EnumMember\n    name: Identifier\n    initializer: IntConstant | null\n    annotations?: Annotations\n}\n\nexport interface TypedefDefinition extends PrimarySyntax {\n    type: SyntaxType.TypedefDefinition\n    name: Identifier\n    definitionType: FieldType\n    annotations?: Annotations\n}\n\nexport interface ServiceDefinition extends PrimarySyntax {\n    type: SyntaxType.ServiceDefinition\n    name: Identifier\n    extends: Identifier | null\n    functions: Array<FunctionDefinition>\n    annotations?: Annotations\n}\n\nexport interface FunctionDefinition extends PrimarySyntax {\n    type: SyntaxType.FunctionDefinition\n    name: Identifier\n    oneway: boolean\n    returnType: FunctionType\n    fields: Array<FieldDefinition>\n    throws: Array<FieldDefinition>\n    modifiers: Array<Token>\n    annotations?: Annotations\n}\n\nexport interface ParametersDefinition extends SyntaxNode {\n    type: SyntaxType.ParametersDefinition\n    fields: Array<FieldDefinition>\n}\n\nexport interface ThrowsDefinition extends SyntaxNode {\n    type: SyntaxType.ThrowsDefinition\n    fields: Array<FieldDefinition>\n}\n\nexport interface StringLiteral extends SyntaxNode {\n    type: SyntaxType.StringLiteral\n    value: string\n}\n\nexport interface BooleanLiteral extends SyntaxNode {\n    type: SyntaxType.BooleanLiteral\n    value: boolean\n}\n\nexport interface IntegerLiteral extends SyntaxNode {\n    type: SyntaxType.IntegerLiteral\n    value: string\n}\n\nexport interface HexLiteral extends SyntaxNode {\n    type: SyntaxType.HexLiteral\n    value: string\n}\n\nexport interface FloatLiteral extends SyntaxNode {\n    type: SyntaxType.FloatLiteral\n    value: string\n}\n\nexport interface ExponentialLiteral extends SyntaxNode {\n    type: SyntaxType.ExponentialLiteral\n    value: string\n}\n\nexport interface IntConstant extends SyntaxNode {\n    type: SyntaxType.IntConstant\n    value: IntegerLiteral | HexLiteral\n}\n\nexport interface DoubleConstant extends SyntaxNode {\n    type: SyntaxType.DoubleConstant\n    value: FloatLiteral | ExponentialLiteral\n}\n\nexport interface ConstMap extends SyntaxNode {\n    type: SyntaxType.ConstMap\n    properties: Array<PropertyAssignment>\n}\n\nexport interface ConstList extends SyntaxNode {\n    type: SyntaxType.ConstList\n    elements: Array<ConstValue>\n}\n\nexport interface PropertyAssignment extends SyntaxNode {\n    type: SyntaxType.PropertyAssignment\n    name: ConstValue\n    initializer: ConstValue\n}\n\nexport interface Identifier extends SyntaxNode {\n    type: SyntaxType.Identifier\n    value: string\n    annotations?: Annotations\n}\n\nexport enum ErrorType {\n    ParseError = 'ParseError',\n    ScanError = 'ScanError',\n}\n\nexport enum SyntaxType {\n    ThriftDocument = 'ThriftDocument',\n    ThriftErrors = 'ThriftErrors',\n\n    Identifier = 'Identifier',\n    FieldID = 'FieldID',\n\n    // Statements\n    NamespaceDefinition = 'NamespaceDefinition',\n    IncludeDefinition = 'IncludeDefinition',\n    CppIncludeDefinition = 'CppIncludeDefinition',\n    ConstDefinition = 'ConstDefinition',\n    StructDefinition = 'StructDefinition',\n    EnumDefinition = 'EnumDefinition',\n    ServiceDefinition = 'ServiceDefinition',\n    ExceptionDefinition = 'ExceptionDefinition',\n    TypedefDefinition = 'TypedefDefinition',\n    UnionDefinition = 'UnionDefinition',\n\n    // Fields\n    FieldDefinition = 'FieldDefinition',\n    FunctionDefinition = 'FunctionDefinition',\n    ParametersDefinition = 'ParametersDefinition',\n    ThrowsDefinition = 'ThrowsDefinition',\n\n    // Type Annotations\n    FieldType = 'FieldType',\n    BaseType = 'BaseType',\n    SetType = 'SetType',\n    MapType = 'MapType',\n    ListType = 'ListType',\n\n    // Values\n    ConstValue = 'ConstValue',\n    IntConstant = 'IntConstant',\n    DoubleConstant = 'DoubleConstant',\n\n    ConstList = 'ConstList',\n    ConstMap = 'ConstMap',\n    EnumMember = 'EnumMember',\n\n    // Literals\n    CommentLine = 'CommentLine',\n    CommentBlock = 'CommentBlock',\n    StringLiteral = 'StringLiteral',\n    IntegerLiteral = 'IntegerLiteral',\n    FloatLiteral = 'FloatLiteral',\n    HexLiteral = 'HexLiteral',\n    ExponentialLiteral = 'ExponentialLiteral',\n    BooleanLiteral = 'BooleanLiteral',\n    PropertyAssignment = 'PropertyAssignment',\n\n    // Tokens\n    LeftParenToken = 'LeftParenToken',\n    RightParenToken = 'RightParenToken',\n    LeftBraceToken = 'LeftBraceToken',\n    RightBraceToken = 'RightBraceToken',\n    LeftBracketToken = 'LeftBracketToken',\n    RightBracketToken = 'RightBracketToken',\n    CommaToken = 'CommaToken',\n    DotToken = 'DotToken',\n    MinusToken = 'MinusToken',\n    SemicolonToken = 'SemicolonToken',\n    ColonToken = 'ColonToken',\n    StarToken = 'StarToken',\n    EqualToken = 'EqualToken',\n    LessThanToken = 'LessThanToken',\n    GreaterThanToken = 'GreaterThanToken',\n\n    // Keywords\n    NamespaceKeyword = 'NamespaceKeyword',\n    IncludeKeyword = 'IncludeKeyword',\n    CppIncludeKeyword = 'CppIncludeKeyword',\n    ExceptionKeyword = 'ExceptionKeyword',\n    ServiceKeyword = 'ServiceKeyword',\n    ExtendsKeyword = 'ExtendsKeyword',\n    RequiredKeyword = 'RequiredKeyword',\n    OptionalKeyword = 'OptionalKeyword',\n    FalseKeyword = 'FalseKeyword',\n    TrueKeyword = 'TrueKeyword',\n    ConstKeyword = 'ConstKeyword',\n    DoubleKeyword = 'DoubleKeyword',\n    StructKeyword = 'StructKeyword',\n    TypedefKeyword = 'TypedefKeyword',\n    UnionKeyword = 'UnionKeyword',\n    StringKeyword = 'StringKeyword',\n    BinaryKeyword = 'BinaryKeyword',\n    BoolKeyword = 'BoolKeyword',\n    ByteKeyword = 'ByteKeyword',\n    EnumKeyword = 'EnumKeyword',\n    SenumKeyword = 'SenumKeyword',\n    ListKeyword = 'ListKeyword',\n    SetKeyword = 'SetKeyword',\n    MapKeyword = 'MapKeyword',\n    I8Keyword = 'I8Keyword',\n    I16Keyword = 'I16Keyword',\n    I32Keyword = 'I32Keyword',\n    I64Keyword = 'I64Keyword',\n    Int8Keyword = 'Int8Keyword',\n    Int16Keyword = 'Int16Keyword',\n    Int32Keyword = 'Int32Keyword',\n    Int64Keyword = 'Int64Keyword',\n    ThrowsKeyword = 'ThrowsKeyword',\n    VoidKeyword = 'VoidKeyword',\n    OnewayKeyword = 'OnewayKeyword',\n\n    // Other\n    Annotation = 'Annotation',\n    Annotations = 'Annotations',\n\n    EOF = 'EOF',\n}\n","import { ErrorType, TextLocation, ThriftError } from './types'\n\nexport type ErrorReporter = (err: ThriftError) => void\n\n\nexport interface Debugger {\n    report: ErrorReporter\n    hasError(): boolean\n    getErrors(): Array<ThriftError>\n    getFormattedErrors(): Array<FormattedError>\n    print(): void\n}\n\nexport interface FormattedError {\n    sourceLine: string\n    locIndicator: string\n    line: number\n    column: number\n    message: string\n    type: ErrorType\n}\n\nexport function noopReporter(err: ThriftError): void {\n    throw new Error(`${err.type}: Line: ${err.loc.start.line}: ${err.message}`)\n}\n\nfunction padLeft(num: number, str: string): string {\n    while (str.length < num) {\n        str = ' ' + str\n    }\n    return str\n}\n\nfunction indicatorForLocaction(loc: TextLocation): string {\n    const indicator: string = padLeft(loc.start.column, '^')\n    return indicator\n}\n\nfunction padStart(length: number, str: string): string {\n    let paddedStr: string = str\n    while (length--) {\n        paddedStr = ' ' + paddedStr\n    }\n\n    return paddedStr\n}\n\nfunction errorType(type: ErrorType): string {\n    switch (type) {\n        case ErrorType.ParseError:\n            return 'Parse Error:'\n\n        case ErrorType.ScanError:\n            return 'Scan Error:'\n    }\n}\n\nexport function createDebugger(source: string): Debugger {\n    // const sourceLines: Array<string> = source.split(os.EOL)\n    const sourceLines: Array<string> = source.split('\\n')\n    const formattedErrors: Array<FormattedError> = []\n    const rawErrors: Array<ThriftError> = []\n\n    function getSourceLine(lineNumber: number): string {\n        return sourceLines[lineNumber - 1]\n    }\n\n    function formatError(err: ThriftError): FormattedError {\n        return {\n            sourceLine: getSourceLine(err.loc.start.line),\n            locIndicator: indicatorForLocaction(err.loc),\n            line: err.loc.start.line,\n            column: err.loc.start.column,\n            message: err.message,\n            type: err.type,\n        }\n    }\n\n    return {\n        hasError(): boolean {\n            return formattedErrors.length > 0\n        },\n\n        getErrors(): Array<ThriftError> {\n            return rawErrors\n        },\n\n        getFormattedErrors(): Array<FormattedError> {\n            return formattedErrors\n        },\n\n        report(err: ThriftError): void {\n            const formattedError: FormattedError = formatError(err)\n            formattedErrors.push(formattedError)\n            rawErrors.push(err)\n        },\n\n        print(): void {\n            console.log(\n                `Parse Failure: ${formattedErrors.length} errors found:`,\n            )\n            console.log()\n            formattedErrors.forEach(\n                (err: FormattedError): void => {\n                    const prefix: string = `${err.line} | `\n\n                    console.log()\n                    console.log(`${errorType(err.type)}\\n`)\n                    console.log(`Message: ${err.message}`)\n                    console.log()\n                    console.log(`${prefix}${err.sourceLine}`)\n                    console.log(padStart(prefix.length, err.locIndicator))\n                    console.log()\n                },\n            )\n        },\n    }\n}\n","import {\n    Annotations,\n    BaseType,\n    BooleanLiteral,\n    Comment,\n    ConstList,\n    ConstMap,\n    ConstValue,\n    DoubleConstant,\n    ErrorType,\n    ExponentialLiteral,\n    FieldDefinition,\n    FieldID,\n    FieldRequired,\n    FieldType,\n    FloatLiteral,\n    FunctionType,\n    HexLiteral,\n    Identifier,\n    IntConstant,\n    IntegerLiteral,\n    KeywordType,\n    ListType,\n    MapType,\n    ParseError,\n    PropertyAssignment,\n    ScanError,\n    SetType,\n    StringLiteral,\n    StructDefinition,\n    SyntaxType,\n    TextLocation,\n    TextPosition,\n    Token,\n} from './types'\n\nexport function createParseError(\n    message: string,\n    loc: TextLocation,\n): ParseError {\n    return {\n        type: ErrorType.ParseError,\n        message,\n        loc,\n    }\n}\n\nexport function createScanError(message: string, loc: TextLocation): ScanError {\n    return {\n        type: ErrorType.ScanError,\n        message,\n        loc,\n    }\n}\n\nexport function createTextLocation(\n    start: TextPosition,\n    end: TextPosition,\n): TextLocation {\n    return { start, end }\n}\n\nexport function createTextPosition(\n    line: number,\n    column: number,\n    index: number,\n): TextPosition {\n    return { line, column, index }\n}\n\nexport function createToken(\n    type: SyntaxType,\n    text: string,\n    loc: TextLocation,\n): Token {\n    return { type, text, loc }\n}\n\nexport function createIdentifier(\n    value: string,\n    loc: TextLocation,\n    annotations?: Annotations,\n): Identifier {\n    return { type: SyntaxType.Identifier, value, loc, annotations }\n}\n\nexport function creataePropertyAssignment(\n    name: ConstValue,\n    initializer: ConstValue,\n    loc: TextLocation,\n): PropertyAssignment {\n    return {\n        type: SyntaxType.PropertyAssignment,\n        name,\n        initializer,\n        loc,\n    }\n}\n\nexport function createFieldDefinition(\n    name: Identifier,\n    fieldID: FieldID,\n    requiredness: FieldRequired,\n    fieldType: FunctionType,\n    loc: TextLocation,\n    defaultValue: ConstValue | null = null,\n    annotations?: Annotations,\n    comments: Array<Comment> = [],\n): FieldDefinition {\n    return {\n        type: SyntaxType.FieldDefinition,\n        name,\n        fieldID,\n        requiredness,\n        fieldType,\n        defaultValue,\n        annotations,\n        comments,\n        loc,\n    }\n}\n\nexport function createFieldID(value: number, loc: TextLocation): FieldID {\n    return {\n        type: SyntaxType.FieldID,\n        value,\n        loc,\n    }\n}\n\nexport function createStructDefinition(\n    name: Identifier,\n    fields: Array<FieldDefinition>,\n    loc: TextLocation,\n    comments: Array<Comment> = [],\n): StructDefinition {\n    return {\n        type: SyntaxType.StructDefinition,\n        name,\n        fields,\n        comments,\n        loc,\n    }\n}\n\nexport function createStringLiteral(\n    value: string,\n    loc: TextLocation,\n): StringLiteral {\n    return {\n        type: SyntaxType.StringLiteral,\n        value,\n        loc,\n    }\n}\n\nexport function createIntegerLiteral(\n    value: string,\n    loc: TextLocation,\n): IntegerLiteral {\n    return { type: SyntaxType.IntegerLiteral, value, loc }\n}\n\nexport function createHexLiteral(value: string, loc: TextLocation): HexLiteral {\n    return { type: SyntaxType.HexLiteral, value, loc }\n}\n\nexport function createFloatLiteral(\n    value: string,\n    loc: TextLocation,\n): FloatLiteral {\n    return { type: SyntaxType.FloatLiteral, value, loc }\n}\n\nexport function createExponentialLiteral(\n    value: string,\n    loc: TextLocation,\n): ExponentialLiteral {\n    return { type: SyntaxType.ExponentialLiteral, value, loc }\n}\n\nexport function createIntConstant(\n    value: IntegerLiteral | HexLiteral,\n    loc: TextLocation,\n): IntConstant {\n    return { type: SyntaxType.IntConstant, value, loc }\n}\n\nexport function createDoubleConstant(\n    value: FloatLiteral | ExponentialLiteral,\n    loc: TextLocation,\n): DoubleConstant {\n    return { type: SyntaxType.DoubleConstant, value, loc }\n}\n\nexport function createBooleanLiteral(\n    value: boolean,\n    loc: TextLocation,\n): BooleanLiteral {\n    return { type: SyntaxType.BooleanLiteral, value, loc }\n}\n\nexport function createKeywordFieldType(\n    type: KeywordType,\n    loc: TextLocation,\n    annotations?: Annotations,\n): BaseType {\n    return { type, loc, annotations }\n}\n\nexport function createMapFieldType(\n    keyType: FieldType,\n    valueType: FieldType,\n    loc: TextLocation,\n    annotations?: Annotations,\n): MapType {\n    return {\n        type: SyntaxType.MapType,\n        keyType,\n        valueType,\n        loc,\n        annotations,\n    }\n}\n\nexport function createSetFieldType(\n    valueType: FieldType,\n    loc: TextLocation,\n    annotations?: Annotations,\n): SetType {\n    return {\n        type: SyntaxType.SetType,\n        valueType,\n        loc,\n        annotations,\n    }\n}\n\nexport function createListFieldType(\n    valueType: FieldType,\n    loc: TextLocation,\n    annotations?: Annotations,\n): ListType {\n    return {\n        type: SyntaxType.ListType,\n        valueType,\n        loc,\n        annotations,\n    }\n}\n\nexport function createConstMap(\n    properties: Array<PropertyAssignment>,\n    loc: TextLocation,\n): ConstMap {\n    return {\n        type: SyntaxType.ConstMap,\n        properties,\n        loc,\n    }\n}\n\nexport function createConstList(\n    elements: Array<ConstValue>,\n    loc: TextLocation,\n): ConstList {\n    return {\n        type: SyntaxType.ConstList,\n        elements,\n        loc,\n    }\n}\n","import { SyntaxType } from './types'\n\nexport interface KeywordMap {\n    [name: string]: SyntaxType\n}\n\nexport const KEYWORDS: KeywordMap = {\n    namespace: SyntaxType.NamespaceKeyword,\n    include: SyntaxType.IncludeKeyword,\n    cpp_include: SyntaxType.CppIncludeKeyword,\n    const: SyntaxType.ConstKeyword,\n    struct: SyntaxType.StructKeyword,\n    service: SyntaxType.ServiceKeyword,\n    extends: SyntaxType.ExtendsKeyword,\n    throws: SyntaxType.ThrowsKeyword,\n    typedef: SyntaxType.TypedefKeyword,\n    union: SyntaxType.UnionKeyword,\n    enum: SyntaxType.EnumKeyword,\n    senum: SyntaxType.SenumKeyword,\n    list: SyntaxType.ListKeyword,\n    set: SyntaxType.SetKeyword,\n    map: SyntaxType.MapKeyword,\n    double: SyntaxType.DoubleKeyword,\n    i8: SyntaxType.I8Keyword,\n    i16: SyntaxType.I16Keyword,\n    i32: SyntaxType.I32Keyword,\n    i64: SyntaxType.I64Keyword,\n    int8: SyntaxType.Int8Keyword,\n    int16: SyntaxType.Int16Keyword,\n    int32: SyntaxType.Int32Keyword,\n    int64: SyntaxType.Int64Keyword,\n    exception: SyntaxType.ExceptionKeyword,\n    binary: SyntaxType.BinaryKeyword,\n    bool: SyntaxType.BoolKeyword,\n    byte: SyntaxType.ByteKeyword,\n    required: SyntaxType.RequiredKeyword,\n    optional: SyntaxType.OptionalKeyword,\n    string: SyntaxType.StringKeyword,\n    true: SyntaxType.TrueKeyword,\n    false: SyntaxType.FalseKeyword,\n    void: SyntaxType.VoidKeyword,\n    oneway: SyntaxType.OnewayKeyword,\n}\n\n\nexport const RESERVEDWORDS = [\n    'break',\n    'case',\n    'catch',\n    'class',\n    'const',\n    'continue',\n    'debugger',\n    'default',\n    'delete',\n    'do',\n    'else',\n    'enum',\n    'export',\n    'extends',\n    'false',\n    'finally',\n    'for',\n    'function',\n    'if',\n    'import',\n    'in',\n    'instanceof',\n    'new',\n    'null',\n    'return',\n    'super',\n    'switch',\n    'this',\n    'throw',\n    'true',\n    'try',\n    'typeof',\n    'var',\n    'void',\n    'while',\n    'with',\n];\n","/* eslint-disable */\nimport {\n  Annotation,\n  Annotations,\n  Comment,\n  ConstDefinition,\n  ConstList,\n  ConstMap,\n  ConstValue,\n  DoubleConstant,\n  EnumDefinition,\n  EnumMember,\n  ExceptionDefinition,\n  FieldDefinition,\n  FieldID,\n  FieldRequired,\n  FieldType,\n  FunctionDefinition,\n  FunctionType,\n  Identifier,\n  IncludeDefinition,\n  IntConstant,\n  ListType,\n  MapType,\n  NamespaceDefinition,\n  ParametersDefinition,\n  PropertyAssignment,\n  ServiceDefinition,\n  SetType,\n  StructDefinition,\n  StructLike,\n  SyntaxType,\n  TextLocation,\n  ThriftDocument,\n  ThriftStatement,\n  ThrowsDefinition,\n  Token,\n  TypedefDefinition,\n  UnionDefinition,\n} from \"./types\";\n\nimport {\n  creataePropertyAssignment,\n  createBooleanLiteral,\n  createConstList,\n  createConstMap,\n  createDoubleConstant,\n  createExponentialLiteral,\n  createFieldID,\n  createFloatLiteral,\n  createHexLiteral,\n  createIdentifier,\n  createIntConstant,\n  createIntegerLiteral,\n  createKeywordFieldType,\n  createMapFieldType,\n  createParseError,\n  createStringLiteral,\n  createTextLocation,\n} from \"./factory\";\n\nimport { ErrorReporter, noopReporter } from \"./debugger\";\nimport { RESERVEDWORDS } from \"./keywords\";\n\nexport interface Parser {\n  parse(): ThriftDocument;\n  synchronize(): void;\n}\n\nfunction isStatementBeginning(token: Token): boolean {\n  switch (token.type) {\n    case SyntaxType.NamespaceKeyword:\n    case SyntaxType.IncludeKeyword:\n    case SyntaxType.ConstKeyword:\n    case SyntaxType.StructKeyword:\n    case SyntaxType.UnionKeyword:\n    case SyntaxType.ExceptionKeyword:\n    case SyntaxType.ServiceKeyword:\n    case SyntaxType.TypedefKeyword:\n    case SyntaxType.EnumKeyword:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass ParseError extends Error {\n  public message: string;\n  public loc: TextLocation;\n  constructor(msg: string, loc: TextLocation) {\n    super(msg);\n    this.message = msg;\n    this.loc = loc;\n  }\n}\n\nexport function createParser(\n  tokens: Array<Token>,\n  report: ErrorReporter = noopReporter,\n  options?: {\n    reservedWord?: \"error\" | \"escape\";\n  }\n): Parser {\n  let comments: Array<Comment> = [];\n  let currentIndex: number = 0;\n\n  // PUBLIC\n  function parse(): ThriftDocument {\n    const thrift: ThriftDocument = {\n      type: SyntaxType.ThriftDocument,\n      body: [],\n    };\n\n    while (!isAtEnd()) {\n      try {\n        const statement: ThriftStatement | null = parseStatement();\n        if (statement !== null) {\n          thrift.body.push(statement);\n        }\n      } catch (e: any) {\n        report(createParseError(e.message, e.loc));\n      }\n    }\n\n    return thrift;\n  }\n\n  // Finds the beginning of the next statement so we can continue parse after error.\n  function synchronize(): void {\n    while (!isAtEnd() && !isStatementBeginning(currentToken())) {\n      advance();\n    }\n  }\n\n  function parseStatement(): ThriftStatement | null {\n    const next: Token = currentToken();\n\n    // All Thrift statements must start with one of these types\n    switch (next.type) {\n      case SyntaxType.NamespaceKeyword:\n        return parseNamespace();\n\n      case SyntaxType.IncludeKeyword:\n        return parseInclude();\n\n      case SyntaxType.ConstKeyword:\n        return parseConst();\n\n      case SyntaxType.StructKeyword:\n        return parseStruct();\n\n      case SyntaxType.UnionKeyword:\n        return parseUnion();\n\n      case SyntaxType.ExceptionKeyword:\n        return parseException();\n\n      case SyntaxType.ServiceKeyword:\n        return parseService();\n\n      case SyntaxType.TypedefKeyword:\n        return parseTypedef();\n\n      case SyntaxType.EnumKeyword:\n        return parseEnum();\n\n      case SyntaxType.CommentBlock:\n      case SyntaxType.CommentLine:\n        consumeComments();\n        return null;\n\n      default:\n        throw reportError(`Invalid start to Thrift statement ${next.text}`);\n    }\n  }\n\n  // IncludeDefinition → 'include' StringLiteral\n  function parseInclude(): IncludeDefinition {\n    const _keywordToken: Token | null = consume(SyntaxType.IncludeKeyword);\n    const keywordToken = requireValue(\n      _keywordToken,\n      `'indcluded' keyword expected`\n    );\n    const _pathToken: Token | null = consume(SyntaxType.StringLiteral);\n    const pathToken = requireValue(\n      _pathToken,\n      `Include statement must include a path as string literal`\n    );\n\n    return {\n      type: SyntaxType.IncludeDefinition,\n      path: createStringLiteral(pathToken.text, pathToken.loc),\n      comments: getComments(),\n      loc: createTextLocation(keywordToken.loc.start, pathToken.loc.end),\n    };\n  }\n\n  // ServiceDefinition → 'service' Identifier ( 'extends' Identifier )? '{' Function* '} Annotations?'\n  function parseService(): ServiceDefinition {\n    const leadingComments: Array<Comment> = getComments();\n    const _keywordToken: Token | null = consume(SyntaxType.ServiceKeyword);\n    const keywordToken: Token = requireValue(\n      _keywordToken,\n      `Unable to find service keyword for service`\n    );\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Unable to find identifier for service`\n    );\n\n    const extendsId: Identifier | null = parseExtends();\n    const _openBrace: Token | null = consume(SyntaxType.LeftBraceToken);\n    const openBrace = requireValue(_openBrace, `Expected opening curly brace`);\n\n    const functions: Array<FunctionDefinition> = parseFunctions();\n    const _closeBrace: Token | null = consume(SyntaxType.RightBraceToken);\n    const closeBrace = requireValue(\n      _closeBrace,\n      `Expected closing curly brace`\n    );\n\n    const annotations: Annotations | undefined = parseAnnotations();\n\n    const location: TextLocation = createTextLocation(\n      keywordToken.loc.start,\n      closeBrace.loc.end\n    );\n\n    return {\n      type: SyntaxType.ServiceDefinition,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      extends: extendsId,\n      functions,\n      annotations,\n      comments: leadingComments,\n      loc: location,\n    };\n  }\n\n  function parseExtends(): Identifier | null {\n    if (checkText(\"extends\")) {\n      const _keywordToken: Token | null = consume(SyntaxType.ExtendsKeyword);\n      const keywordToken = requireValue(\n        _keywordToken,\n        `'extends keyword expected`\n      );\n      const _nameToken: Token | null = consume(SyntaxType.Identifier);\n      const nameToken = requireValue(\n        _nameToken,\n        `Identifier expected after 'extends' keyword`\n      );\n\n      return createIdentifier(\n        nameToken.text,\n        createTextLocation(keywordToken.loc.start, nameToken.loc.end)\n      );\n    } else {\n      return null;\n    }\n  }\n\n  function parseFunctions(): Array<FunctionDefinition> {\n    const functions: Array<FunctionDefinition> = [];\n\n    while (!check(SyntaxType.RightBraceToken)) {\n      if (check(SyntaxType.CommentBlock, SyntaxType.CommentLine)) {\n        advance();\n      } else {\n        functions.push(parseFunction());\n\n        if (isStatementBeginning(currentToken())) {\n          throw reportError(\n            `Closing curly brace expected, but new statement found`\n          );\n        } else if (check(SyntaxType.EOF)) {\n          throw reportError(\n            `Closing curly brace expected but reached end of file`\n          );\n        }\n      }\n    }\n\n    return functions;\n  }\n\n  // Function → 'oneway'? FunctionType Identifier '(' Field* ')' Throws? Annotations? ListSeparator?\n  function parseFunction(): FunctionDefinition {\n    const leadingComments: Array<Comment> = getComments();\n    const onewayToken: Token | null = consume(SyntaxType.OnewayKeyword);\n    const returnType: FunctionType = parseFunctionType();\n\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Unable to find function identifier`\n    );\n\n    const params: ParametersDefinition = parseParameterFields();\n\n    const throws: ThrowsDefinition | null = parseThrows();\n\n    const annotations: Annotations | undefined = parseAnnotations();\n\n    const listSeparator: Token | null = readListSeparator();\n    const endLoc: TextLocation =\n      listSeparator !== null\n        ? listSeparator.loc\n        : throws !== null\n          ? throws.loc\n          : params.loc;\n\n    return {\n      type: SyntaxType.FunctionDefinition,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      returnType,\n      fields: params.fields,\n      throws: throws !== null ? throws.fields : [],\n      annotations,\n      comments: leadingComments,\n      oneway: onewayToken !== null,\n      modifiers: onewayToken !== null ? [onewayToken] : [],\n      loc: {\n        start: returnType.loc.start,\n        end: endLoc.end,\n      },\n    };\n  }\n\n  function parseParameterFields(): ParametersDefinition {\n    const fields: Array<FieldDefinition> = [];\n    const _openParen: Token | null = consume(SyntaxType.LeftParenToken);\n    const openParen: Token = requireValue(\n      _openParen,\n      `Opening paren expected to start list of fields`\n    );\n\n    while (!check(SyntaxType.RightParenToken)) {\n      readListSeparator();\n      fields.push(parseField());\n\n      if (isStatementBeginning(currentToken())) {\n        throw reportError(\n          `Closing paren ')' expected, but new statement found`\n        );\n      } else if (check(SyntaxType.EOF)) {\n        throw reportError(`Closing paren ')' expected but reached end of file`);\n      }\n    }\n\n    const _closeParen: Token | null = consume(SyntaxType.RightParenToken);\n    const closeParen: Token = requireValue(\n      _closeParen,\n      `Closing paren expected to end list of fields`\n    );\n\n    return {\n      type: SyntaxType.ParametersDefinition,\n      fields,\n      loc: {\n        start: openParen.loc.start,\n        end: closeParen.loc.end,\n      },\n    };\n  }\n\n  // Throws → 'throws' '(' Field* ')'\n  function parseThrows(): ThrowsDefinition | null {\n    if (check(SyntaxType.ThrowsKeyword)) {\n      const _keywordToken: Token | null = consume(SyntaxType.ThrowsKeyword);\n      const keywordToken: Token = requireValue(\n        _keywordToken,\n        `'throws' keyword expected`\n      );\n      const params: ParametersDefinition = parseParameterFields();\n\n      return {\n        type: SyntaxType.ThrowsDefinition,\n        fields: params.fields,\n        loc: {\n          start: keywordToken.loc.start,\n          end: params.loc.end,\n        },\n      };\n    }\n\n    return null;\n  }\n\n  // Namespace → 'namespace' ( NamespaceScope Identifier )\n  function parseNamespace(): NamespaceDefinition {\n    const _keywordToken: Token | null = consume(SyntaxType.NamespaceKeyword);\n    const keywordToken: Token = requireValue(\n      _keywordToken,\n      `'namespace' keyword expected`\n    );\n    const _scopeToken: Token | null = consume(SyntaxType.Identifier);\n    const scopeToken: Token = requireValue(\n      _scopeToken,\n      `Unable to find scope identifier for namespace`\n    );\n\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n\n    if (_nameToken && options?.reservedWord === \"escape\") {\n      const nameTokenText = escapeReservedWordForIdentifier(_nameToken.text);\n      _nameToken.text = nameTokenText;\n    }\n\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Unable to find name identifier for namespace`\n    );\n\n    return {\n      type: SyntaxType.NamespaceDefinition,\n      scope: createIdentifier(scopeToken.text, scopeToken.loc),\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      comments: getComments(),\n      loc: createTextLocation(keywordToken.loc.start, nameToken.loc.end),\n    };\n  }\n\n  // ConstDefinition → 'const' FieldType Identifier '=' ConstValue Annotations? ListSeparator?\n  function parseConst(): ConstDefinition {\n    const leadingComments: Array<Comment> = getComments();\n    const _keywordToken: Token | null = consume(SyntaxType.ConstKeyword);\n    const keywordToken: Token = requireValue(\n      _keywordToken,\n      `'const' keyword expected`\n    );\n    const fieldType: FieldType = parseFieldType();\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Const definition must have a name`\n    );\n\n    const _initializer: ConstValue | null = parseValueAssignment();\n    const initializer: ConstValue = requireValue(\n      _initializer,\n      `Const must be initialized to a value`\n    );\n\n    const annotations: Annotations | undefined = parseAnnotations();\n    readListSeparator();\n\n    return {\n      type: SyntaxType.ConstDefinition,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      fieldType,\n      initializer,\n      annotations,\n      comments: leadingComments,\n      loc: {\n        start: keywordToken.loc.start,\n        end: initializer.loc.end,\n      },\n    };\n  }\n\n  function parseValueAssignment(): ConstValue | null {\n    if (check(SyntaxType.EqualToken)) {\n      advance();\n      return parseValue();\n    }\n\n    return null;\n  }\n\n  // Annotations → '(' Annotation* ')'\n  function parseAnnotations(): Annotations | undefined {\n    if (check(SyntaxType.LeftParenToken)) {\n      const annotations: Array<Annotation> = [];\n      const startToken = advance();\n      while (!check(SyntaxType.RightParenToken)) {\n        annotations.push(parseAnnotation());\n      }\n      const endToken = advance();\n      return {\n        annotations,\n        type: SyntaxType.Annotations,\n        loc: createTextLocation(startToken.loc.start, endToken.loc.end),\n      };\n    }\n\n    return undefined;\n  }\n\n  // Annotation → Identifier ('=' StringLiteral)? ListSeparator?\n  function parseAnnotation(): Annotation {\n    const nameToken: Token = requireValue(\n      consume(SyntaxType.Identifier),\n      `Annotation must have a name`\n    );\n    let valueToken: Token | undefined;\n    if (check(SyntaxType.EqualToken)) {\n      advance();\n      valueToken = requireValue(\n        consume(SyntaxType.StringLiteral),\n        `Annotation must have a value`\n      );\n    }\n\n    readListSeparator();\n\n    return {\n      type: SyntaxType.Annotation,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      value: valueToken\n        ? createStringLiteral(valueToken.text, valueToken.loc)\n        : undefined,\n      loc: createTextLocation(\n        nameToken.loc.start,\n        (valueToken || nameToken).loc.end\n      ),\n    };\n  }\n\n  // TypedefDefinition → 'typedef' FieldType Identifier\n  function parseTypedef(): TypedefDefinition {\n    const _keywordToken: Token | null = consume(SyntaxType.TypedefKeyword);\n    const keywordToken: Token = requireValue(\n      _keywordToken,\n      `'typedef' keyword expected`\n    );\n    const type: FieldType = parseFieldType();\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Typedef is expected to have name and none found`\n    );\n\n    const leadingComments: Array<Comment> = getComments();\n\n    const annotations: Annotations | undefined = parseAnnotations();\n\n    return {\n      type: SyntaxType.TypedefDefinition,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      definitionType: type,\n      annotations,\n      comments: leadingComments,\n      loc: {\n        start: keywordToken.loc.start,\n        end: nameToken.loc.end,\n      },\n    };\n  }\n\n  // EnumDefinition → 'enum' Identifier '{' EnumMember* '} Annotations?'\n  function parseEnum(): EnumDefinition {\n    const leadingComments: Array<Comment> = getComments();\n    const _keywordToken: Token | null = consume(SyntaxType.EnumKeyword);\n    const keywordToken: Token = requireValue(\n      _keywordToken,\n      `'enum' keyword expected`\n    );\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Expected identifier for enum definition`\n    );\n\n    const openBrace: Token | null = consume(SyntaxType.LeftBraceToken);\n    requireValue(openBrace, `Expected opening brace`);\n\n    const members: Array<EnumMember> = parseEnumMembers();\n    const _closeBrace: Token | null = consume(SyntaxType.RightBraceToken);\n    const closeBrace: Token = requireValue(\n      _closeBrace,\n      `Expected closing brace`\n    );\n\n    const annotations: Annotations | undefined = parseAnnotations();\n\n    const loc: TextLocation = {\n      start: keywordToken.loc.start,\n      end: closeBrace.loc.end,\n    };\n\n    return {\n      type: SyntaxType.EnumDefinition,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      members,\n      annotations,\n      comments: leadingComments,\n      loc,\n    };\n  }\n\n  function parseEnumMembers(): Array<EnumMember> {\n    const members: Array<EnumMember> = [];\n    while (!check(SyntaxType.RightBraceToken)) {\n      if (check(SyntaxType.CommentBlock, SyntaxType.CommentLine)) {\n        advance();\n      } else {\n        members.push(parseEnumMember());\n\n        // consume list separator if there is one\n        readListSeparator();\n        if (isStatementBeginning(currentToken())) {\n          throw reportError(\n            `Closing curly brace expected, but new statement found`\n          );\n        } else if (check(SyntaxType.EOF)) {\n          throw reportError(\n            `Closing curly brace expected but reached end of file`\n          );\n        }\n      }\n    }\n\n    return members;\n  }\n\n  // EnumMember → (Identifier ('=' IntConstant)? Annotations? ListSeparator?)*\n  function parseEnumMember(): EnumMember {\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `EnumMember must have identifier`\n    );\n\n    let loc: TextLocation | null = null;\n    let initializer: IntConstant | null = null;\n    if (consume(SyntaxType.EqualToken) !== null) {\n      const _numToken: Token | null = consume(\n        SyntaxType.IntegerLiteral,\n        SyntaxType.HexLiteral\n      );\n      const numToken: Token = requireValue(\n        _numToken,\n        `Equals token \"=\" must be followed by an Integer`\n      );\n      initializer = parseIntValue(numToken);\n      loc = createTextLocation(nameToken.loc.start, initializer.loc.end);\n    } else {\n      loc = createTextLocation(nameToken.loc.start, nameToken.loc.end);\n    }\n\n    const annotations: Annotations | undefined = parseAnnotations();\n\n    return {\n      type: SyntaxType.EnumMember,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      initializer,\n      annotations,\n      comments: getComments(),\n      loc,\n    };\n  }\n\n  // StructLike → ('struct' | 'union' | 'exception') Identifier 'xsd_all'? '{' Field* '} Annotations?'\n  function parseStructLikeInterface(): StructLike {\n    const leadingComments: Array<Comment> = getComments();\n    const _keywordToken: Token | null = consume(\n      SyntaxType.StructKeyword,\n      SyntaxType.UnionKeyword,\n      SyntaxType.ExceptionKeyword\n    );\n    const keywordToken: Token = requireValue(\n      _keywordToken,\n      `'struct | union | exception' expected`\n    );\n    const _nameToken: Token | null = consume(SyntaxType.Identifier);\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Struct-like must have an identifier`\n    );\n\n    const openBrace: Token | null = consume(SyntaxType.LeftBraceToken);\n    requireValue(\n      openBrace,\n      `Struct-like body must begin with opening curly brace '{'`\n    );\n\n    const fields: Array<FieldDefinition> = parseFields();\n    const _closeBrace: Token | null = consume(SyntaxType.RightBraceToken);\n    const closeBrace: Token = requireValue(\n      _closeBrace,\n      `Struct-like body must end with a closing curly brace '}'`\n    );\n\n    const annotations: Annotations | undefined = parseAnnotations();\n\n    return {\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      fields,\n      annotations,\n      comments: leadingComments,\n      loc: {\n        start: keywordToken.loc.start,\n        end: closeBrace.loc.end,\n      },\n    };\n  }\n\n  // StructDefinition → 'struct' Identifier 'xsd_all'? '{' Field* '} Annotations?'\n  function parseStruct(): StructDefinition {\n    const parsedData: StructLike = parseStructLikeInterface();\n\n    return {\n      type: SyntaxType.StructDefinition,\n      name: parsedData.name,\n      fields: parsedData.fields,\n      annotations: parsedData.annotations,\n      comments: parsedData.comments,\n      loc: parsedData.loc,\n    };\n  }\n\n  // UnioinDefinition → 'union' Identifier 'xsd_all'? '{' Field* '} Annotations?'\n  function parseUnion(): UnionDefinition {\n    const parsedData: StructLike = parseStructLikeInterface();\n\n    return {\n      type: SyntaxType.UnionDefinition,\n      name: parsedData.name,\n      fields: parsedData.fields.map((next: FieldDefinition) => {\n        // As per the Thrift spec, all union fields are optional\n        next.requiredness = \"optional\";\n        return next;\n      }),\n      annotations: parsedData.annotations,\n      comments: parsedData.comments,\n      loc: parsedData.loc,\n    };\n  }\n\n  // ExceptionDefinition → 'exception' Identifier '{' Field* '} Annotations?'\n  function parseException(): ExceptionDefinition {\n    const parsedData: StructLike = parseStructLikeInterface();\n\n    return {\n      type: SyntaxType.ExceptionDefinition,\n      name: parsedData.name,\n      fields: parsedData.fields,\n      annotations: parsedData.annotations,\n      comments: parsedData.comments,\n      loc: parsedData.loc,\n    };\n  }\n\n  function parseFields(): Array<FieldDefinition> {\n    const fields: Array<FieldDefinition> = [];\n\n    while (!check(SyntaxType.RightBraceToken)) {\n      if (check(SyntaxType.CommentBlock, SyntaxType.CommentLine)) {\n        advance();\n      } else {\n        fields.push(parseField());\n\n        if (isStatementBeginning(currentToken())) {\n          throw reportError(\n            `Closing curly brace expected, but new statement found`\n          );\n        } else if (check(SyntaxType.EOF)) {\n          throw reportError(\n            `Closing curly brace expected but reached end of file`\n          );\n        }\n      }\n    }\n\n    return fields;\n  }\n\n  // Field → FieldID? FieldReq? FieldType Identifier ('= ConstValue)? XsdFieldOptions Annotations? ListSeparator?\n  function parseField(): FieldDefinition {\n    const startLoc: TextLocation = currentToken().loc;\n    const fieldID: FieldID | null = parseFieldId();\n    const fieldRequired: FieldRequired | null = parserequireValuedness();\n    const fieldType: FieldType = parseFieldType();\n    // 在scanner处理的时候，把list直接识别成SyntaxType.ListKeyword，但是根据idl来看这样是合法的\n    // 实际应该集合parse的上下文进行修正\n    const _nameToken: Token | null = parseValidIdentifier();\n\n    const nameToken: Token = requireValue(\n      _nameToken,\n      `Unable to find identifier for field`\n    );\n\n    const defaultValue: ConstValue | null = parseValueAssignment();\n    const annotations: Annotations | undefined = parseAnnotations();\n    const listSeparator: Token | null = readListSeparator();\n\n    const endLoc: TextLocation =\n      listSeparator !== null\n        ? listSeparator.loc\n        : defaultValue !== null\n          ? defaultValue.loc\n          : nameToken.loc;\n\n    const location: TextLocation = createTextLocation(\n      startLoc.start,\n      endLoc.end\n    );\n\n    return {\n      type: SyntaxType.FieldDefinition,\n      name: createIdentifier(nameToken.text, nameToken.loc),\n      fieldID,\n      fieldType,\n      requiredness: fieldRequired,\n      defaultValue,\n      comments: getComments(),\n      annotations,\n      loc: location,\n    };\n  }\n\n  // ListSeparator → ',' | ';'\n  function readListSeparator(): Token | null {\n    if (check(SyntaxType.CommaToken, SyntaxType.SemicolonToken)) {\n      return advance();\n    }\n\n    return null;\n  }\n\n  // FieldRequired → 'required' | 'optional'\n  function parserequireValuedness(): FieldRequired | null {\n    const current: Token = currentToken();\n    if (current.text === \"required\" || current.text === \"optional\") {\n      advance();\n      return current.text;\n    }\n\n    return null;\n  }\n\n  // FieldID → IntConstant ':'\n  function parseFieldId(): FieldID | null {\n    if (\n      currentToken().type === SyntaxType.IntegerLiteral &&\n      peek().type === SyntaxType.ColonToken\n    ) {\n      const fieldIDToken: Token | null = consume(SyntaxType.IntegerLiteral);\n      const colonToken: Token | null = consume(SyntaxType.ColonToken);\n\n      // return value of number token\n      return createFieldID(\n        parseInt(fieldIDToken!.text, 10),\n        createTextLocation(fieldIDToken!.loc.start, colonToken!.loc.end)\n      );\n    } else {\n      return null;\n    }\n  }\n\n  // ConstValue → Literal | ConstMap | ConstList\n  function parseValue(): ConstValue | null {\n    const next: Token = advance();\n    switch (next.type) {\n      case SyntaxType.Identifier:\n        return createIdentifier(next.text, next.loc);\n\n      case SyntaxType.StringLiteral:\n        return createStringLiteral(next.text, next.loc);\n\n      case SyntaxType.IntegerLiteral:\n      case SyntaxType.HexLiteral:\n        return parseIntValue(next);\n\n      case SyntaxType.FloatLiteral:\n      case SyntaxType.ExponentialLiteral:\n        return parseDoubleValue(next);\n\n      case SyntaxType.TrueKeyword:\n        return createBooleanLiteral(true, next.loc);\n\n      case SyntaxType.FalseKeyword:\n        return createBooleanLiteral(false, next.loc);\n\n      case SyntaxType.LeftBraceToken:\n        return parseMapValue();\n\n      case SyntaxType.LeftBracketToken:\n        return parseListValue();\n\n      default:\n        return null;\n    }\n  }\n\n  function parseIntValue(token: Token): IntConstant {\n    switch (token.type) {\n      case SyntaxType.IntegerLiteral:\n        return createIntConstant(\n          createIntegerLiteral(token.text, token.loc),\n          token.loc\n        );\n\n      case SyntaxType.HexLiteral:\n        return createIntConstant(\n          createHexLiteral(token.text, token.loc),\n          token.loc\n        );\n\n      default:\n        throw reportError(`IntConstant expected but found: ${token.type}`);\n    }\n  }\n\n  function parseDoubleValue(token: Token): DoubleConstant {\n    switch (token.type) {\n      case SyntaxType.FloatLiteral:\n        return createDoubleConstant(\n          createFloatLiteral(token.text, token.loc),\n          token.loc\n        );\n\n      case SyntaxType.ExponentialLiteral:\n        return createDoubleConstant(\n          createExponentialLiteral(token.text, token.loc),\n          token.loc\n        );\n\n      default:\n        throw reportError(`DoubleConstant expected but found: ${token.type}`);\n    }\n  }\n\n  // ConstMap → '{' (ConstValue ':' ConstValue ListSeparator?)* '}'\n  function parseMapValue(): ConstMap {\n    // The parseValue method has already advanced the cursor\n    const startLoc: TextLocation = currentToken().loc;\n    const properties: Array<PropertyAssignment> = check(\n      SyntaxType.RightBraceToken\n    )\n      ? []\n      : readMapValues();\n    const _closeBrace: Token | null = consume(SyntaxType.RightBraceToken);\n    const closeBrace: Token = requireValue(\n      _closeBrace,\n      `Closing brace missing from map definition`\n    );\n\n    const endLoc: TextLocation = closeBrace.loc;\n    const location: TextLocation = {\n      start: startLoc.start,\n      end: endLoc.end,\n    };\n\n    return createConstMap(properties, location);\n  }\n\n  // ConstList → '[' (ConstValue ListSeparator?)* ']'\n  function parseListValue(): ConstList {\n    // The parseValue method has already advanced the cursor\n    const startLoc: TextLocation = currentToken().loc;\n    const elements: Array<ConstValue> = check(SyntaxType.RightBracketToken)\n      ? []\n      : readListValues();\n    const _closeBrace: Token | null = consume(SyntaxType.RightBracketToken);\n    const closeBrace: Token = requireValue(\n      _closeBrace,\n      `Closing square-bracket missing from list definition`\n    );\n    const endLoc: TextLocation = closeBrace.loc;\n\n    return createConstList(elements, {\n      start: startLoc.start,\n      end: endLoc.end,\n    });\n  }\n\n  function readMapValues(): Array<PropertyAssignment> {\n    const properties: Array<PropertyAssignment> = [];\n    while (true) {\n      const _key: ConstValue | null = parseValue();\n      const key: ConstValue = requireValue(_key, \"Key expected for map value\");\n      const semicolon: Token | null = consume(SyntaxType.ColonToken);\n      requireValue(\n        semicolon,\n        `Semicolon expected after key in map property assignment`\n      );\n      const _value: ConstValue | null = parseValue();\n      const value: ConstValue = requireValue(_value, \"\");\n\n      properties.push(\n        creataePropertyAssignment(key, value, {\n          start: key.loc.start,\n          end: value.loc.end,\n        })\n      );\n\n      if (check(SyntaxType.CommaToken)) {\n        advance();\n\n        // trailing comma\n        if (check(SyntaxType.RightBraceToken)) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return properties;\n  }\n\n  function readListValues(): Array<ConstValue> {\n    const elements: Array<ConstValue> = [];\n    while (true) {\n      const value: ConstValue | null = parseValue();\n      if (value !== null) {\n        elements.push(value);\n      }\n\n      if (check(SyntaxType.CommaToken, SyntaxType.SemicolonToken)) {\n        advance();\n\n        // trailing comma\n        if (check(SyntaxType.RightBracketToken)) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    return elements;\n  }\n\n  // FunctionType → FieldType | 'void'\n  function parseFunctionType(): FunctionType {\n    const typeToken: Token | null = consume(SyntaxType.VoidKeyword);\n    if (typeToken !== null) {\n      return {\n        type: SyntaxType.VoidKeyword,\n        loc: typeToken.loc,\n      };\n    } else {\n      return parseFieldType();\n    }\n  }\n\n  const IdentifierRegExp = /^[_a-zA-Z][-._a-zA-Z0-9]*$/;\n\n  function parseValidIdentifier(): Token | null {\n    const token = advance();\n\n    // 参看 scanner 的 identifier 的判断\n    if (IdentifierRegExp.test(token.text)) {\n      token.type = SyntaxType.Identifier;\n\n      return token;\n    }\n\n    return null;\n  }\n\n  // FieldType → Identifier | BaseType | ContainerType\n  function parseFieldType(): FieldType {\n    const typeToken: Token = advance();\n    switch (typeToken.type) {\n      case SyntaxType.Identifier:\n        let text = typeToken.text;\n        if (options?.reservedWord === \"escape\") {\n          text = escapeReservedWordForIdentifier(typeToken.text);\n        }\n\n        return createIdentifier(text, typeToken.loc, parseAnnotations());\n\n      case SyntaxType.MapKeyword:\n        return parseMapType();\n\n      case SyntaxType.ListKeyword:\n        return parseListType();\n\n      case SyntaxType.SetKeyword:\n        return parseSetType();\n\n      case SyntaxType.BinaryKeyword:\n      case SyntaxType.BoolKeyword:\n      case SyntaxType.ByteKeyword:\n      case SyntaxType.StringKeyword:\n      case SyntaxType.I8Keyword:\n      case SyntaxType.I16Keyword:\n      case SyntaxType.I32Keyword:\n      case SyntaxType.I64Keyword:\n      case SyntaxType.Int8Keyword:\n      case SyntaxType.Int16Keyword:\n      case SyntaxType.Int32Keyword:\n      case SyntaxType.Int64Keyword:\n      case SyntaxType.DoubleKeyword:\n        return createKeywordFieldType(\n          typeToken.type,\n          typeToken.loc,\n          parseAnnotations()\n        );\n\n      default:\n        throw reportError(`FieldType expected but found: ${typeToken.type}`);\n    }\n  }\n\n  // MapType → 'map' CppType? '<' FieldType ',' FieldType '>'\n  function parseMapType(): MapType {\n    const _openBracket: Token | null = consume(SyntaxType.LessThanToken);\n    const openBracket: Token = requireValue(\n      _openBracket,\n      `Map needs to defined contained types`\n    );\n\n    const keyType: FieldType = parseFieldType();\n    const _commaToken: Token | null = consume(SyntaxType.CommaToken);\n    const commaToken: Token = requireValue(\n      _commaToken,\n      `Comma expected to separate map types <key, value>`\n    );\n\n    const valueType: FieldType = parseFieldType();\n    const _closeBracket: Token | null = consume(SyntaxType.GreaterThanToken);\n    const closeBracket: Token = requireValue(\n      _closeBracket,\n      `Map needs to defined contained types`\n    );\n\n    const location: TextLocation = {\n      start: openBracket.loc.start,\n      end: closeBracket.loc.end,\n    };\n\n    return createMapFieldType(keyType, valueType, location, parseAnnotations());\n  }\n\n  // SetType → 'set' CppType? '<' FieldType '>'\n  function parseSetType(): SetType {\n    const _openBracket: Token | null = consume(SyntaxType.LessThanToken);\n    const openBracket: Token = requireValue(\n      _openBracket,\n      `Map needs to defined contained types`\n    );\n\n    const valueType: FieldType = parseFieldType();\n    const _closeBracket: Token | null = consume(SyntaxType.GreaterThanToken);\n    const closeBracket: Token = requireValue(\n      _closeBracket,\n      `Map needs to defined contained types`\n    );\n\n    return {\n      type: SyntaxType.SetType,\n      valueType,\n      loc: {\n        start: openBracket.loc.start,\n        end: closeBracket.loc.end,\n      },\n      annotations: parseAnnotations(),\n    };\n  }\n\n  // ListType → 'list' '<' FieldType '>' CppType?\n  function parseListType(): ListType {\n    const _openBracket: Token | null = consume(SyntaxType.LessThanToken);\n    const openBracket: Token = requireValue(\n      _openBracket,\n      `Map needs to defined contained types`\n    );\n\n    const valueType: FieldType = parseFieldType();\n    const _closeBracket: Token | null = consume(SyntaxType.GreaterThanToken);\n    const closeBracket: Token = requireValue(\n      _closeBracket,\n      `Map needs to defined contained types`\n    );\n\n    return {\n      type: SyntaxType.ListType,\n      valueType,\n      loc: {\n        start: openBracket.loc.start,\n        end: closeBracket.loc.end,\n      },\n      annotations: parseAnnotations(),\n    };\n  }\n\n  const ReservedWordsForIdentifierRegExp = new RegExp(\n    `(?<=\\\\.|^)(?:${RESERVEDWORDS.map((v) => `(${v})`).join(\"|\")})(?=\\\\.|$)`,\n    \"g\"\n  );\n\n  function escapeReservedWordForIdentifier(text: string): string {\n    const originText = text;\n    let replaceCount = 0;\n\n    const replacedText = originText.replace(\n      ReservedWordsForIdentifierRegExp,\n      (value: string) => {\n        replaceCount++;\n\n        return `${value[0].toUpperCase()}${value.substring(1)}`;\n      }\n    );\n\n    if (replaceCount) {\n      return replacedText;\n    }\n\n    return originText;\n  }\n\n  function consumeComments(): void {\n    while (true) {\n      const next: Token = tokens[currentIndex];\n      switch (next.type) {\n        case SyntaxType.CommentBlock:\n          comments.push({\n            type: next.type,\n            value: next.text.split(\"\\n\"),\n            loc: next.loc,\n          });\n          currentIndex++;\n          break;\n\n        case SyntaxType.CommentLine:\n          comments.push({\n            type: next.type,\n            value: next.text,\n            loc: next.loc,\n          });\n          currentIndex++;\n          break;\n\n        default:\n          return;\n      }\n    }\n  }\n\n  function currentToken(): Token {\n    consumeComments();\n    return tokens[currentIndex];\n  }\n\n  function previousToken(): Token {\n    return tokens[currentIndex - 1];\n  }\n\n  function peek(): Token {\n    return tokens[currentIndex + 1];\n  }\n\n  // Does the current token match the given type\n  function check(...types: Array<SyntaxType>): boolean {\n    for (const type of types) {\n      if (type === currentToken().type) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // Does the current token match the given text\n  function checkText(...strs: Array<string>): boolean {\n    for (const str of strs) {\n      if (str === currentToken().text) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // requireToken the current token to match given type and advance, otherwise return null\n  function consume(...types: Array<SyntaxType>): Token | null {\n    for (const type of types) {\n      if (check(type)) {\n        return advance();\n      }\n    }\n\n    return null;\n  }\n\n  // Move the cursor forward and return the previous token\n  function advance(): Token {\n    if (!isAtEnd()) {\n      currentIndex += 1;\n    }\n\n    return previousToken();\n  }\n\n  function isAtEnd(): boolean {\n    return (\n      currentIndex >= tokens.length || currentToken().type === SyntaxType.EOF\n    );\n  }\n\n  function getComments(): Array<Comment> {\n    const current: Array<Comment> = comments;\n    comments = [];\n    return current;\n  }\n\n  function reportError(msg: string): Error {\n    return new ParseError(msg, previousToken().loc);\n  }\n\n  // Throw if the given value doesn't exist.\n  function requireValue<T>(val: T | null, msg: string): T {\n    if (val === null || val === undefined) {\n      throw reportError(msg);\n    } else {\n      return val;\n    }\n  }\n\n  return {\n    parse,\n    synchronize,\n  };\n}\n","/* eslint-disable */\nimport { ErrorReporter, noopReporter } from \"./debugger\";\nimport { createScanError, createToken } from \"./factory\";\nimport { KEYWORDS } from \"./keywords\";\nimport { SyntaxType, TextLocation, Token } from \"./types\";\n\nfunction isDigit(value: string): boolean {\n  return value >= \"0\" && value <= \"9\";\n}\n\nfunction isAlpha(value: string): boolean {\n  return (value >= \"a\" && value <= \"z\") || (value >= \"A\" && value <= \"Z\");\n}\n\n// The first character of an Identifier can be a letter or underscore\nfunction isAlphaOrUnderscore(value: string): boolean {\n  return isAlpha(value) || value === \"_\";\n}\n\nfunction isValidIdentifier(value: string): boolean {\n  return (\n    isAlphaOrUnderscore(value) ||\n    isDigit(value) ||\n    value === \".\" ||\n    value === \"-\"\n  );\n}\n\nfunction isHexDigit(value: string): boolean {\n  return (\n    (value >= \"0\" && value <= \"9\") ||\n    (value >= \"A\" && value <= \"F\") ||\n    (value >= \"a\" && value <= \"f\")\n  );\n}\n\nfunction isWhiteSpace(char: string): boolean {\n  switch (char) {\n    case \" \":\n    case \"\\r\":\n    case \"\\t\":\n    case \"\\n\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass ScanError extends Error {\n  public message: string;\n  public loc: TextLocation;\n  constructor(msg: string, loc: TextLocation) {\n    super(msg);\n    this.message = msg;\n    this.loc = loc;\n  }\n}\n\nexport interface Scanner {\n  scan(): Array<Token>;\n  syncronize(): void;\n}\n\nexport function createScanner(\n  src: string,\n  report: ErrorReporter = noopReporter\n) {\n  const source: string = src;\n  const tokens: Array<Token> = [];\n  let line: number = 1;\n  let column: number = 1;\n  let startLine: number = 1;\n  let startColumn: number = 1;\n  let startIndex: number = 0;\n  let currentIndex: number = 0;\n\n  function scan(): Array<Token> {\n    while (!isAtEnd()) {\n      try {\n        startIndex = currentIndex;\n        startLine = line;\n        startColumn = column;\n        scanToken();\n      } catch (e: any) {\n        report(createScanError(e.message, e.loc));\n      }\n    }\n\n    startIndex = currentIndex;\n    addToken(SyntaxType.EOF);\n\n    return tokens;\n  }\n\n  // Find the beginning of the next word to restart parse after error\n  function syncronize(): void {\n    while (!isAtEnd() && !isWhiteSpace(current())) {\n      advance();\n    }\n  }\n\n  function scanToken(): void {\n    const next = advance();\n    switch (next) {\n      case \" \":\n      case \"\\r\":\n      case \"\\t\":\n        // Ignore whitespace.\n        break;\n\n      case \"\\n\":\n        nextLine();\n        break;\n\n      case \"&\":\n        // Thirft supports (undocumented by the grammar) a syntax for c-style pointers\n        // Pointers are indicated by the '&' token. As these are not relevant to JavaScript we\n        // drop them here. This may not be the best thing to do, perhaps should leave them in\n        // the parse tree and allow consumers to deal.\n        break;\n\n      case \"=\":\n        addToken(SyntaxType.EqualToken);\n        break;\n\n      case \"(\":\n        addToken(SyntaxType.LeftParenToken);\n        break;\n\n      case \")\":\n        addToken(SyntaxType.RightParenToken);\n        break;\n\n      case \"{\":\n        addToken(SyntaxType.LeftBraceToken);\n        break;\n\n      case \"}\":\n        addToken(SyntaxType.RightBraceToken);\n        break;\n\n      case \"[\":\n        addToken(SyntaxType.LeftBracketToken);\n        break;\n\n      case \"]\":\n        addToken(SyntaxType.RightBracketToken);\n        break;\n\n      case \";\":\n        addToken(SyntaxType.SemicolonToken);\n        break;\n\n      case \",\":\n        addToken(SyntaxType.CommaToken);\n        break;\n\n      // Strings can use single or double quotes\n      case '\"':\n      case \"'\":\n        string(next);\n        break;\n\n      case \":\":\n        addToken(SyntaxType.ColonToken);\n        break;\n\n      case \"#\":\n        singleLineComment();\n        break;\n\n      case \"/\":\n        if (peek() === \"/\") {\n          singleLineComment();\n        } else if (peek() === \"*\") {\n          multilineComment();\n        } else {\n          reportError(`Unexpected token: ${next}`);\n        }\n        break;\n\n      case \"<\":\n        addToken(SyntaxType.LessThanToken);\n        break;\n\n      case \">\":\n        addToken(SyntaxType.GreaterThanToken);\n        break;\n\n      case \"-\":\n        if (isDigit(peek())) {\n          number();\n        } else {\n          addToken(SyntaxType.MinusToken);\n        }\n        break;\n\n      default:\n        if (isDigit(next)) {\n          number();\n        } else if (isAlphaOrUnderscore(next)) {\n          identifier();\n        } else if (isValidIdentifier(next)) {\n          reportError(\n            `Invalid identifier '${next}': Identifiers must begin with a letter or underscore`\n          );\n        } else {\n          reportError(`Unexpected token: ${next}`);\n        }\n    }\n  }\n\n  function identifier(): void {\n    while (!isAtEnd() && peek() !== \"\\n\" && isValidIdentifier(peek())) {\n      advance();\n    }\n\n    const literal: string = source.substring(startIndex, currentIndex);\n\n    const isKeyword = Object.keys(KEYWORDS).includes(literal);\n    if (!isKeyword) {\n      addToken(SyntaxType.Identifier, literal);\n    } else {\n      const type: SyntaxType = KEYWORDS[literal];\n      addToken(type, literal);\n    }\n  }\n\n  function number(): void {\n    if (current() === \"0\" && (consume(\"x\") || consume(\"X\"))) {\n      hexadecimal();\n    } else {\n      integer();\n\n      if (peek() === \"e\" || peek() === \"E\") {\n        enotation();\n      } else if (peek() === \".\" && isDigit(peekNext())) {\n        float();\n      } else {\n        commitToken(SyntaxType.IntegerLiteral);\n      }\n    }\n  }\n\n  function hexadecimal(): void {\n    while (!isAtEnd() && peek() !== \"\\n\" && isHexDigit(peek())) {\n      advance();\n    }\n\n    commitToken(SyntaxType.HexLiteral);\n  }\n\n  function enotation(): void {\n    consume(\"e\") || consume(\"E\");\n    consume(\"-\") || consume(\"+\");\n    if (isDigit(peek())) {\n      integer();\n      commitToken(SyntaxType.ExponentialLiteral);\n    } else {\n      reportError(`Invalid use of e-notation`);\n    }\n  }\n\n  function float(): void {\n    consume(\".\");\n    integer();\n\n    if (peek() === \"e\" || peek() === \"E\") {\n      enotation();\n    } else {\n      commitToken(SyntaxType.FloatLiteral);\n    }\n  }\n\n  function integer(): void {\n    while (!isAtEnd() && peek() !== \"\\n\" && isDigit(peek())) {\n      advance();\n    }\n  }\n\n  function singleLineComment(): void {\n    let comment: string = \"\";\n\n    while (true) {\n      if (\n        current() === \"\\n\" ||\n        isAtEnd() ||\n        (current() !== \"/\" && current() !== \"#\" && current() !== \" \")\n      ) {\n        break;\n      } else {\n        advance();\n      }\n    }\n\n    if (current() !== \"\\n\") {\n      // A comment goes until the end of the line.\n      while (peek() !== \"\\n\" && !isAtEnd()) {\n        comment += current();\n        advance();\n      }\n\n      comment += current();\n    }\n\n    addToken(SyntaxType.CommentLine, comment.trim());\n  }\n\n  // TODO: optimize the logic\n  function multilineComment(): void {\n    let comment: string = \"\";\n    let cursor: number = 0;\n\n    while (true) {\n      if (\n        current() === \"\\n\" ||\n        isAtEnd() ||\n        (current() !== \"/\" && current() !== \"*\") ||\n        (current() === \"*\" && peek() === \"*\" && peekNext() === \"/\")\n      ) {\n        break;\n      } else {\n        advance();\n      }\n    }\n\n    while (true) {\n      if (current() === \"\\n\") {\n        nextLine();\n      }\n\n      // A comment goes until we find a comment terminator (*/).\n      if ((peek() === \"*\" && peekNext() === \"/\") || isAtEnd()) {\n        advance();\n        advance();\n        break;\n      }\n\n      if (\n        comment.charAt(cursor - 1) === \"\\n\" &&\n        (peek() === \" \" || peek() === \"*\")\n      ) {\n        /**\n         * We ignore stars and spaces after a new line to normalize comment formatting.\n         * We're only keeping the text of the comment without the extranious formatting.\n         */\n      } else {\n        comment += current();\n        cursor += 1;\n      }\n\n      advance();\n\n      // A comment goes until we find a comment terminator (*/).\n      if ((peek() === \"*\" && peekNext() === \"/\") || isAtEnd()) {\n        advance();\n        advance();\n        break;\n      }\n    }\n\n    addToken(SyntaxType.CommentBlock, comment.trim());\n  }\n\n  function string(terminator: string): void {\n    while (!isAtEnd() && peek() !== terminator) {\n      if (peek() === \"\\n\") {\n        nextLine();\n      }\n      if (peek() === \"\\\\\") {\n        advance();\n      }\n\n      advance();\n    }\n\n    if (isAtEnd() && previous() !== terminator) {\n      reportError(`String must be terminated with ${terminator}`);\n    } else {\n      // advance past closing \"\n      advance();\n      // We use \"+ 1\" and \"- 1\" to remove the quote markes from the string and unsescape escaped terminators\n      const literal: string = source\n        .substring(startIndex + 1, currentIndex - 1)\n        .replace(/\\\\(\\\"|\\')/g, \"$1\");\n      addToken(SyntaxType.StringLiteral, literal);\n    }\n  }\n\n  function consume(text: string): boolean {\n    if (peek() === text) {\n      advance();\n      return true;\n    }\n\n    return false;\n  }\n\n  function advance(): string {\n    currentIndex++;\n    column++;\n    return source.charAt(currentIndex - 1);\n  }\n\n  function previous(): string {\n    return source.charAt(currentIndex - 2);\n  }\n\n  function current(): string {\n    return source.charAt(currentIndex - 1);\n  }\n\n  function peek(): string {\n    return source.charAt(currentIndex);\n  }\n\n  function peekNext(): string {\n    return source.charAt(currentIndex + 1);\n  }\n\n  function nextLine() {\n    line++;\n    column = 1;\n  }\n\n  function commitToken(type: SyntaxType): void {\n    const literal: string = source.substring(startIndex, currentIndex);\n    addToken(type, literal);\n  }\n\n  function currentLocation(): TextLocation {\n    return {\n      start: {\n        line: startLine,\n        column: startColumn,\n        index: startIndex,\n      },\n      end: {\n        line,\n        column,\n        index: currentIndex,\n      },\n    };\n  }\n\n  function addToken(type: SyntaxType, value: string = \"\"): void {\n    const loc: TextLocation = currentLocation();\n    tokens.push(createToken(type, value, loc));\n  }\n\n  function isAtEnd(): boolean {\n    return currentIndex >= source.length;\n  }\n\n  function reportError(msg: string): void {\n    throw new ScanError(msg, currentLocation());\n  }\n\n  return {\n    scan,\n    syncronize,\n  };\n}\n","// import * as fs from \"node:fs\";\n// import * as path from \"path\";\nimport { createDebugger, Debugger } from \"./debugger\";\nimport { organize } from \"./organizer\";\nimport { createParser, Parser } from \"./parser\";\nimport { createScanner, Scanner } from \"./scanner\";\nimport {\n  ErrorType,\n  SyntaxType,\n  ThriftDocument,\n  ThriftError,\n  ThriftErrors,\n  Token,\n} from \"./types\";\n\nexport * from \"./types\";\nexport * from \"./factory\";\nexport { createScanner } from \"./scanner\";\nexport { createParser } from \"./parser\";\n\nexport interface ParseOptions {\n  fastFail: boolean;\n  rootDir: string;\n  outDir: string;\n  files: Array<string>;\n  organize: boolean;\n  reservedWord?: \"error\" | \"escape\";\n}\n\nexport const defaultOptions: ParseOptions = {\n  fastFail: false,\n  rootDir: \".\",\n  outDir: \".\",\n  files: [],\n  organize: true,\n  reservedWord: \"error\",\n};\n\n// export function parseFiles(\n//   options: Partial<ParseOptions> = {}\n// ): Array<ThriftDocument | ThriftErrors> {\n//   const mergedOptions: ParseOptions = { ...defaultOptions, ...options };\n//   return mergedOptions.files.map(\n//     (file: string): ThriftDocument | ThriftErrors => {\n//       const filePath: string = path.resolve(\n//         process.cwd(),\n//         mergedOptions.rootDir,\n//         file\n//       );\n//       const content: string = fs.readFileSync(filePath, \"utf-8\");\n//       return parse(content, mergedOptions);\n//     }\n//   );\n// }\n\nexport function parse(\n  source: string,\n  options: Partial<ParseOptions> = {}\n): ThriftDocument | ThriftErrors {\n  // HACK: 末尾加上一个不存在的const来获取末尾的注释\n  source += \"\\nconst i32 liuqi=1995\";\n  const mergedOptions: ParseOptions = { ...defaultOptions, ...options };\n  const debug: Debugger = createDebugger(source);\n  const scanner: Scanner = createScanner(source, handleError);\n  const tokens: Array<Token> = scanner.scan();\n\n  const parser: Parser = createParser(tokens, handleError, {\n    reservedWord: options.reservedWord,\n  });\n  const intermediate: ThriftDocument = parser.parse();\n  const thrift: ThriftDocument = mergedOptions.organize\n    ? organize(intermediate)\n    : intermediate;\n\n  /**\n   * This is a safe handler for errors that allows the parser and scanner to recover to a\n   * reasonable state after an error and continue with the parse. If an error occurs we will\n   * not return any output, but using this allows us to catch more errors and report them to\n   * the user at once instead of the work flow of find error -> fix error, find error -> fix error.\n   *\n   * @param err\n   */\n  function handleError(err: ThriftError): void {\n    debug.report(err);\n    if (mergedOptions.fastFail) {\n      debug.print();\n      throw new Error(err.message);\n    } else {\n      switch (err.type) {\n        case ErrorType.ParseError:\n          parser.synchronize();\n          break;\n\n        case ErrorType.ScanError:\n          scanner.syncronize();\n          break;\n      }\n    }\n  }\n\n  if (debug.hasError()) {\n    debug.print();\n    return {\n      type: SyntaxType.ThriftErrors,\n      errors: debug.getErrors(),\n    };\n  } else {\n    return thrift;\n  }\n}\n","import {\n  ThriftDocument,\n  SyntaxType,\n  Comment,\n  ServiceDefinition,\n  StructLike,\n  PrimarySyntax,\n  EnumDefinition\n} from './@creditkarma/thrift-parser';\n\nexport const collectCommentsAndPrimarySyntax = (\n  ast: ThriftDocument\n): {\n  comments: Comment[];\n  primarySyntaxNodes: PrimarySyntax[];\n} => {\n  const comments: Comment[] = [];\n  const primarySyntaxNodes: PrimarySyntax[] = [];\n  // 从这些内容里面获取comment用于重构\n  const primarySyntaxType = [\n    SyntaxType.IncludeDefinition,\n    SyntaxType.ServiceDefinition,\n    SyntaxType.FunctionDefinition,\n    SyntaxType.NamespaceDefinition,\n    SyntaxType.ConstDefinition,\n    SyntaxType.TypedefDefinition,\n    SyntaxType.EnumDefinition,\n    SyntaxType.EnumMember,\n    SyntaxType.StructDefinition,\n    SyntaxType.UnionDefinition,\n    SyntaxType.ExceptionDefinition,\n    SyntaxType.FieldDefinition\n  ];\n  const hasChildrenType = [\n    SyntaxType.ServiceDefinition,\n    SyntaxType.EnumDefinition,\n    SyntaxType.StructDefinition,\n    SyntaxType.UnionDefinition,\n    SyntaxType.ExceptionDefinition\n  ];\n  // 从单个元素中收集comments\n  const collectSingleComments = (item: PrimarySyntax): void => {\n    if (item.comments.length) {\n      comments.push(...item.comments);\n    }\n  };\n  ast.body.forEach(thriftStatement => {\n    const type = thriftStatement.type;\n    primarySyntaxNodes.push(thriftStatement);\n    if (primarySyntaxType.includes(type)) {\n      if (hasChildrenType.includes(type)) {\n        switch (type) {\n          case SyntaxType.ServiceDefinition:\n            (thriftStatement as ServiceDefinition).functions.forEach(item => {\n              // TODO: 考虑FunctionDefinition中包含的FieldDefinition的注释。。\n              /**\n               * 例如：\n               * service CollectService {\n               *     Collection Collect(\n               *         1:i32 req // 奇怪的注释，感觉不想允许它的存在\n               *     )  (method = 'GET',  uri = '/api/collect'),\n               * }\n               */\n              collectSingleComments(item);\n              primarySyntaxNodes.push(item);\n            });\n            break;\n          case SyntaxType.EnumDefinition:\n            (thriftStatement as EnumDefinition).members.forEach(item => {\n              collectSingleComments(item);\n              primarySyntaxNodes.push(item);\n            });\n            break;\n          case SyntaxType.StructDefinition:\n          case SyntaxType.UnionDefinition:\n          case SyntaxType.ExceptionDefinition:\n            (thriftStatement as StructLike).fields.forEach(item => {\n              collectSingleComments(item);\n              primarySyntaxNodes.push(item);\n            });\n            break;\n        }\n      }\n      collectSingleComments(thriftStatement);\n    }\n  });\n  return {\n    comments: comments.sort((a, b) => a.loc.start.index - b.loc.start.index),\n    // 有序之后做二分查找\n    primarySyntaxNodes: primarySyntaxNodes.sort(\n      (a, b) => a.loc.start.index - b.loc.start.index\n    )\n  };\n};\n\nexport const handleComments = (ast: ThriftDocument): ThriftDocument => {\n  const { comments, primarySyntaxNodes } = collectCommentsAndPrimarySyntax(ast);\n  // 先把所有的primarySyntaxNodes初始化\n  primarySyntaxNodes.forEach(node => {\n    node.commentsBefore = [];\n    node.commentsAfter = [];\n  });\n  // 配对O(n2) TODO: 优化到O(nlogn)，如果没有性能问题就不管了\n  // 规则：\n  // - line相同，比较index，comment.index > PrimarySyntax.index，\n  //    认为是PrimarySyntax的commentsBefore，comment.index < PrimarySyntax.index，认为是PrimarySyntax的commentsAfter\n  // - 多个line相同的取先出现的，即index小的\n  // - 没有line相同的，取comment.index > PrimarySyntax.index且argmin( PrimarySyntax.index)，\n  //    即最接近且在comment之后的PrimarySyntax，认为是PrimarySyntax的commentsBefore\n  comments.forEach(commemt => {\n    let targetNode: PrimarySyntax | undefined;\n    const commentEndIndex = commemt.loc.end.index;\n    targetNode = primarySyntaxNodes.find(\n      pNode => pNode.loc.end.line === commemt.loc.end.line\n    );\n    if (targetNode) {\n      if (targetNode.loc.start.index > commentEndIndex) {\n        targetNode.commentsBefore!.push(commemt);\n      } else {\n        targetNode.commentsAfter!.push(commemt);\n      }\n      return;\n    }\n    let i;\n    for (i = 0; i < primarySyntaxNodes.length; i++) {\n      const nodeStartIndex = primarySyntaxNodes[i].loc.start.index;\n      if (i === 0 && nodeStartIndex > commentEndIndex) {\n        targetNode = primarySyntaxNodes[0];\n        break;\n      }\n      // TODO: 处理位于idl末尾的comment\n      if (\n        nodeStartIndex > commentEndIndex &&\n        primarySyntaxNodes[i - 1].loc.start.index < nodeStartIndex\n      ) {\n        targetNode = primarySyntaxNodes[i];\n        break;\n      }\n    }\n\n    if (targetNode) {\n      targetNode.commentsBefore!.push(commemt);\n    }\n  });\n  // 上面用的是浅拷贝直接修改原数据\n  return ast;\n};\n","/* eslint-disable */\nimport {\n  parse,\n  ThriftDocument,\n  ThriftErrors,\n  SyntaxType,\n  ThriftStatement,\n  FunctionType,\n  FieldDefinition,\n  FunctionDefinition,\n  EnumDefinition,\n  ConstDefinition,\n  DoubleConstant,\n  IntConstant,\n  StringLiteral,\n} from \"./@creditkarma/thrift-parser\";\nimport {\n  RpcEntity,\n  CMDOptions,\n  InterfacePropertyEntity,\n  InterfaceEntity,\n  TypeDefEntity,\n  ServiceEntity,\n  FunctionEntity,\n  EnumEntity,\n  EnumEntityMember,\n  ConstantEntity,\n  ConstantEntityType,\n} from \"./interfaces\";\nimport { handleComments } from \"./handleComments\";\n// import * as fs from \"fs-extra\";\nimport { isUndefined } from \"../tools/utils\";\nimport chalk from \"chalk\";\n\nconst error = chalk.bgRed.white.bold;\n\nexport async function readCode(\n  filefullname: string,\n  options?: Partial<CMDOptions>, // TODO 添加option支持\n  includeMap?: { [key: string]: RpcEntity }\n): Promise<RpcEntity> {\n  // const source = await fs.readFile(filefullname);\n  const source = \"\";\n  return parser(filefullname, source.toString(), options, includeMap);\n}\n\nexport function parser(\n  filefullname: string,\n  source: string,\n  options?: Partial<CMDOptions>, // TODO 添加option支持\n  includeMap?: { [key: string]: RpcEntity }\n): RpcEntity {\n  const ast: ThriftDocument | ThriftErrors = parse(source, {\n    reservedWord: options?.reservedWord || \"error\",\n  });\n\n  if (!isThritDocument(ast)) {\n    alert(\"thrift格式不正确\");\n    throw new Error(\"thrift parser error:\" + filefullname);\n  }\n  handleComments(ast);\n  //   if (options && options.annotationConfigPath) {\n  //     if (fs.existsSync(options.annotationConfigPath)) {\n  //       try {\n  //         options.annotationConfig = JSON.parse(\n  //           fs.readFileSync(options.annotationConfigPath, \"utf8\")\n  //         );\n  //       } catch (e) {\n  //         console.error(e);\n  //       }\n  //     }\n  //   }\n\n  const rtn: RpcEntity = {\n    ns: \"\",\n    fileName: filefullname,\n    includes: [],\n    interfaces: [],\n    enums: [],\n    typeDefs: [],\n    services: [],\n    consts: [],\n  };\n\n  const namespaces: { [key: string]: string } = {};\n\n  ast.body.forEach((ts: ThriftStatement) => {\n    // namespace\n    if (ts.type === SyntaxType.NamespaceDefinition) {\n      // namespace 的处理逻辑，抓一个就来了\n      // TODO 优先考虑js的namespace，之后是go，再之后随便抓一个\n      namespaces[ts.scope.value] = ts.name.value;\n    }\n    // includes\n    if (ts.type === SyntaxType.IncludeDefinition) {\n      rtn.includes.push(ts.path.value);\n    }\n    // struct like: struct exception union --> interfaces\n    if (\n      ts.type === SyntaxType.StructDefinition ||\n      ts.type === SyntaxType.UnionDefinition ||\n      ts.type === SyntaxType.ExceptionDefinition\n    ) {\n      const name: string = ts.name.value;\n      const aInterface: InterfaceEntity = {\n        name,\n        properties: {},\n        loc: ts.loc,\n        comments: ts.comments,\n        commentsAfter: ts.commentsAfter,\n        commentsBefore: ts.commentsBefore,\n      };\n      // 添加属性\n      ts.fields.forEach((field: any) => {\n        const { entity: temp, name } = handleField(\n          field,\n          options,\n          ts.name.value\n        );\n        aInterface.properties[name] = temp;\n      });\n      rtn.interfaces.push(aInterface);\n    }\n\n    // typedef\n    if (ts.type === SyntaxType.TypedefDefinition) {\n      const aTypeDef: TypeDefEntity = {\n        type: \"\",\n        alias: \"\",\n        comments: ts.comments,\n        commentsAfter: ts.commentsAfter,\n        commentsBefore: ts.commentsBefore,\n        loc: ts.loc,\n      };\n      aTypeDef.alias = ts.name.value;\n      aTypeDef.type = getFieldTypeString(ts.definitionType, options, ts);\n      rtn.typeDefs.push(aTypeDef);\n    }\n\n    // service\n    if (ts.type === SyntaxType.ServiceDefinition) {\n      const aService: ServiceEntity = {\n        name: ts.name.value,\n        interfaces: {},\n        comments: ts.comments,\n        commentsAfter: ts.commentsAfter,\n        commentsBefore: ts.commentsBefore,\n        loc: ts.loc,\n      };\n      ts.functions.forEach((func) => {\n        aService.interfaces[func.name.value] = handleFunction(func, options);\n      });\n      rtn.services.push(aService);\n    }\n\n    // enum\n    if (ts.type === SyntaxType.EnumDefinition) {\n      rtn.enums.push(handleEnum(ts));\n    }\n\n    // const 考虑支持\n    if (ts.type === SyntaxType.ConstDefinition) {\n      const temp = handleConst(ts);\n      if (temp !== false) {\n        rtn.consts.push(temp);\n      }\n    }\n  });\n\n  const namespacesValues = Object.values(namespaces);\n  rtn.ns = namespaces.js || namespaces.go;\n  if (!rtn.ns && namespacesValues.length) {\n    rtn.ns = namespacesValues[0];\n  }\n\n  /* istanbul ignore if */\n  if (includeMap) {\n    includeMap[rtn.fileName] = rtn;\n  }\n  return rtn;\n}\n\nfunction isThritDocument(\n  ast: ThriftDocument | ThriftErrors\n): ast is ThriftDocument {\n  return ast.type === SyntaxType.ThriftDocument;\n}\n\n/**\n *\n * @param {ThriftDocument} ast thrift-parser输出的ast\n * @returns {RpcEntity} 返回rpc\n */\nexport function transformAst(ast: ThriftDocument): RpcEntity {\n  return {} as any;\n}\n\nfunction getFieldTypeString(\n  fieldType: FunctionType,\n  options: Partial<CMDOptions> = {},\n  field: Record<string, any> = {}\n): string {\n  const i64Type = \"Int64\";\n  const { mapType = \"Record\" } = options;\n  const ThriftType2JavascriptType: { [key: string]: string } = {\n    [SyntaxType.BoolKeyword]: \"boolean\",\n    [SyntaxType.ByteKeyword]: \"number\",\n    [SyntaxType.I8Keyword]: \"number\",\n    [SyntaxType.I16Keyword]: \"number\",\n    [SyntaxType.I32Keyword]: \"number\",\n    [SyntaxType.I64Keyword]: i64Type,\n    [SyntaxType.Int8Keyword]: \"number\",\n    [SyntaxType.Int16Keyword]: \"number\",\n    [SyntaxType.Int32Keyword]: \"number\",\n    [SyntaxType.Int64Keyword]: i64Type,\n    [SyntaxType.DoubleKeyword]: \"number\",\n    [SyntaxType.StringKeyword]: \"string\",\n    [SyntaxType.BinaryKeyword]: \"any\",\n    [SyntaxType.ListKeyword]: \"Array\",\n    [SyntaxType.MapKeyword]: \"Map\",\n    [SyntaxType.SetKeyword]: \"Set\",\n    // UPDATE 添加void\n    [SyntaxType.VoidKeyword]: \"void\",\n  };\n\n  if (options)\n    if (fieldType.type === SyntaxType.Identifier) {\n      return fieldType.value;\n    }\n  if (fieldType.type === SyntaxType.SetType) {\n    return `Set<${getFieldTypeString(\n      fieldType.valueType,\n      options,\n      fieldType\n    )}>`;\n  }\n  if (fieldType.type === SyntaxType.ListType) {\n    return `${getFieldTypeString(fieldType.valueType, options, fieldType)}[]`;\n  }\n  if (fieldType.type === SyntaxType.MapType) {\n    if (mapType === \"Record\") {\n      return `${mapType}<string, ${getFieldTypeString(\n        fieldType.valueType,\n        options,\n        fieldType\n      )}>`;\n    }\n    return `${mapType}<${getFieldTypeString(\n      fieldType.keyType,\n      options,\n      fieldType\n    )}, ${getFieldTypeString(fieldType.valueType, options, fieldType)}>`;\n  }\n  if (fieldType.type === SyntaxType.I64Keyword) {\n    console.log(\n      error(`WARN: 存在i64类型字段: ${field?.name?.value}，该类型定义可能错误`)\n    );\n  }\n  return ThriftType2JavascriptType[fieldType.type];\n}\n\ninterface IhandleField {\n  entity: InterfacePropertyEntity;\n  name: string;\n}\n\nfunction handleField(\n  field: FieldDefinition,\n  options: Partial<CMDOptions> = {},\n  structName = \"\"\n): IhandleField {\n  let name = field.name.value;\n  const commentsBefore = field.commentsBefore || [];\n  // 需要处理typedef\n  const type = getFieldTypeString(field.fieldType, options, field);\n  const index = field.fieldID ? field.fieldID.value : 0;\n  // 考虑多种type数据的default value StringLiteral | IntConstant | DoubleConstant | BooleanLiteral | ConstMap | ConstList | Identifier\n  let defaultValue: string | undefined;\n  if (field.defaultValue !== null) {\n    switch (field.defaultValue.type) {\n      case SyntaxType.StringLiteral:\n        defaultValue = field.defaultValue.value;\n        break;\n      case SyntaxType.IntConstant:\n        defaultValue = field.defaultValue.value.value;\n        break;\n      case SyntaxType.DoubleConstant:\n        defaultValue = field.defaultValue.value.value;\n        break;\n      case SyntaxType.BooleanLiteral:\n        defaultValue = String(field.defaultValue.value);\n        break;\n      case SyntaxType.ConstMap:\n        // 简单的处理\n        defaultValue = \"Map\";\n        break;\n      case SyntaxType.ConstList:\n        // 简单的处理2\n        defaultValue = \"List\";\n        break;\n      case SyntaxType.Identifier:\n        defaultValue = field.defaultValue.value;\n        break;\n    }\n  }\n\n  if (options.useTag) {\n    const annotations = field.annotations;\n    const tagValueReg = /json:\"([\\w_\\d]+).*\"/;\n    const tagNameReg = /(\\w+).tag/;\n    if (annotations) {\n      const nameTag = annotations.annotations.find(\n        (annotation: { name: { value: string } }) => {\n          let match;\n          if ((match = tagNameReg.exec(annotation.name.value))) {\n            return match[1] === options.useTag;\n          }\n          return false;\n        }\n      );\n      if (nameTag) {\n        const match = tagValueReg.exec(\n          nameTag.value ? nameTag.value.value : \"\"\n        );\n        if (match) {\n          name = match[1];\n        }\n      }\n    }\n  }\n  // annotation config 优先级高于useTag\n  if (options && options.annotationConfig) {\n    const { fieldComment, fieldKey } = options.annotationConfig;\n    if (\n      field.annotations &&\n      Array.isArray(field.annotations.annotations) &&\n      (Array.isArray(fieldComment) || fieldKey)\n    ) {\n      let comment = \"\";\n      field.annotations.annotations.forEach((annotation) => {\n        if (Array.isArray(fieldComment)) {\n          if (fieldComment.indexOf(annotation.name.value) > -1) {\n            comment += `@${annotation.name.value}:${\n              annotation!.value!.value\n            }    `;\n          }\n        }\n        let fieldKeyArr: string[];\n        // 支持fieldKey是个数组\n        if (Array.isArray(fieldKey)) {\n          fieldKeyArr = fieldKey;\n        } else {\n          fieldKeyArr = [fieldKey || \"___some_error_value___\"];\n        }\n        // 如果存在多个annotation命中，后面的覆盖前面的\n        if (fieldKeyArr.length) {\n          if (fieldKeyArr.indexOf(annotation.name.value) > -1) {\n            name = annotation!.value!.value;\n          }\n        }\n      });\n      commentsBefore.push({\n        type: SyntaxType.CommentLine,\n        value: comment,\n        loc: field.loc,\n      });\n    }\n  }\n\n  let optional = false;\n  if (field.requiredness === \"required\") {\n    optional = false;\n  } else if (field.requiredness === \"optional\") {\n    optional = true;\n  } else {\n    const isRes = /response/i.test(structName);\n    const isReq = /request/i.test(structName);\n    const useStrict = options.useStrictMode;\n    const useStrictReq = options.strictReq;\n    const hasDefault = !isUndefined(defaultValue);\n\n    if (useStrict) {\n      optional = true;\n    }\n    if (isReq && useStrictReq) {\n      optional = true;\n    }\n    if (isReq && hasDefault) {\n      optional = true;\n    }\n    if (!isRes && !isReq && hasDefault) {\n      optional = true;\n    }\n  }\n\n  if (!isUndefined(defaultValue)) {\n    let value = defaultValue;\n    if (defaultValue === \"\") {\n      value = '\"\"';\n    }\n\n    commentsBefore.push({\n      type: SyntaxType.CommentLine,\n      value: `@default: ${value}`,\n      loc: field.loc,\n    });\n  } else {\n    defaultValue = \"\";\n  }\n\n  return {\n    entity: {\n      type,\n      index,\n      optional,\n      defaultValue,\n      comments: field.comments,\n      commentsBefore,\n      commentsAfter: field.commentsAfter,\n      loc: field.loc,\n    },\n    name,\n  };\n}\n\n/*\n  returnType: string;\n  inputParams: Array<{\n    type: string;\n    index: number;\n    name: string;\n  }>;\n  comment: string;\n */\nfunction handleFunction(\n  func: FunctionDefinition,\n  options?: Partial<CMDOptions> | undefined\n): FunctionEntity {\n  const returnType = getFieldTypeString(func.returnType, options, func);\n  const inputParams = func.fields.map((field: any) => {\n    const { entity: temp, name } = handleField(field, options);\n    return {\n      type: temp.type,\n      index: temp.index,\n      name,\n    };\n  });\n  let comment = \"\";\n  if (options && options.annotationConfig) {\n    // 根据annotation生成config\n    const { functionMethod, functionUri } = options.annotationConfig;\n    if (functionMethod || functionUri) {\n      if (func.annotations && Array.isArray(func.annotations.annotations)) {\n        func.annotations.annotations.forEach((annotation) => {\n          if (functionMethod) {\n            if (annotation.name.value === functionMethod) {\n              comment += `@method: ${annotation!.value!.value}    `;\n            }\n          }\n          if (functionUri) {\n            if (annotation.name.value === functionUri) {\n              comment += `@uri: ${annotation!.value!.value}    `;\n            }\n          }\n        });\n      }\n    }\n    const { fieldComment } = options.annotationConfig;\n    if (\n      func.annotations &&\n      Array.isArray(func.annotations.annotations) &&\n      Array.isArray(fieldComment)\n    ) {\n      func.annotations.annotations.forEach((annotation) => {\n        if (Array.isArray(fieldComment)) {\n          if (fieldComment.indexOf(annotation.name.value) > -1) {\n            comment += `@${annotation.name.value}: ${\n              annotation!.value!.value\n            }    `;\n          }\n        }\n      });\n    }\n  }\n  const commentsBefore = func.commentsBefore || [];\n  if (comment) {\n    commentsBefore.push({\n      loc: func.loc,\n      value: comment,\n      type: SyntaxType.CommentLine,\n    });\n  }\n  return {\n    returnType,\n    inputParams,\n    comments: [],\n    loc: func.loc,\n    commentsBefore,\n    commentsAfter: func.commentsAfter,\n  };\n}\n\nfunction handleConst(\n  c: ConstDefinition,\n  options?: CMDOptions\n): ConstantEntity | false {\n  let cType;\n  let value;\n  const constType = c.fieldType.type;\n  if (\n    c.name.value === \"liuqi\" &&\n    (c.initializer as IntConstant).value.value === \"1995\"\n  ) {\n    return false;\n  }\n  if (\n    constType === SyntaxType.DoubleKeyword ||\n    constType === SyntaxType.I8Keyword ||\n    constType === SyntaxType.I16Keyword ||\n    constType === SyntaxType.I32Keyword ||\n    constType === SyntaxType.I64Keyword ||\n    constType === SyntaxType.Int8Keyword ||\n    constType === SyntaxType.Int16Keyword ||\n    constType === SyntaxType.Int32Keyword ||\n    constType === SyntaxType.Int64Keyword ||\n    constType === SyntaxType.ByteKeyword\n  ) {\n    cType = constType;\n    value = (c.initializer as IntConstant | DoubleConstant).value.value;\n  } else if (constType === SyntaxType.StringKeyword) {\n    cType = constType;\n    value = (c.initializer as StringLiteral).value;\n  } else {\n    return false;\n  }\n  let typeString = getFieldTypeString(c.fieldType, options, c);\n  if (typeString === \"Int64\") {\n    typeString = \"string\";\n  }\n\n  const name = c.name.value;\n  return {\n    type: cType as ConstantEntityType,\n    value,\n    name,\n    comments: c.comments,\n    loc: c.loc,\n    typeString,\n  };\n}\n\nfunction handleEnum(e: EnumDefinition, options?: CMDOptions): EnumEntity {\n  const name = e.name.value;\n  const properties: {\n    [key: string]: EnumEntityMember;\n  } = {};\n  let currentValue = 0;\n  e.members.forEach((member) => {\n    /**\n     * https://wiki.apache.org/thrift/Tutorial\n     * You can define enums, which are just 32 bit integers. Values are optional\n     * and start at 1 if not supplied, C style again.\n     *              ^ ThriftIDL page says \"If no constant value is supplied,\n     *   the value is either 0 for the first element, or one greater than the\n     *   preceding value for any subsequent element\" so I'm guessing that's a bug.\n     *   PS: http://enel.ucalgary.ca/People/Norman/enel315_winter1997/enum_types/ states that if values are not supplied, they start at 0 and not 1.\n     */\n    let value: number;\n    if (member.initializer) {\n      value = parseInt(member.initializer.value.value, 10);\n    } else {\n      value = currentValue++;\n    }\n    properties[member.name.value] = {\n      value,\n      loc: member.loc,\n      comments: member.comments,\n      commentsBefore: member.commentsBefore,\n      commentsAfter: member.commentsAfter,\n    };\n  });\n  return {\n    name,\n    properties,\n    loc: e.loc,\n    comments: e.comments,\n    commentsBefore: e.commentsBefore,\n    commentsAfter: e.commentsAfter,\n  };\n}\n","/* eslint-disable */\n// import * as fs from \"fs-extra\";\n\nexport function isUndefined(v: any): v is undefined {\n  return typeof v === \"undefined\";\n}\n\n// export function replaceTsHelperInt64(filePath: string) {\n//   const strToReplace = `declare var Int64: {\n//     prototype: Int64;\n//     new (): Int64;\n// };\n// interface Int64 {\n//     toString(): string;\n// }\n// declare type ReqNumber = number | string | Int64;\n// declare type RespNumber = Int64;\n// declare type WrapperReqNumber<T> = Int64 extends T ? ReqNumber : T extends number[] ? ReqNumber[] : T;\n// declare type WrapperRespNumber<T> = T extends number ? RespNumber : T extends number[] ? RespNumber[] : T;`;\n//   const newStr = `declare type Int64 = string;\n// declare type ReqNumber = number | string | Int64;\n// declare type RespNumber = Int64;\n// declare type WrapperReqNumber<T> = T;\n// declare type WrapperRespNumber<T> = T;`;\n//   fs.writeFileSync(\n//     filePath,\n//     fs.readFileSync(filePath).toString().replace(strToReplace, newStr)\n//   );\n// }\n","/* eslint-disable */\nimport {\n  SyntaxType,\n  Comment,\n  CommentLine,\n  CommentBlock,\n  TextLocation,\n} from \"./@creditkarma/thrift-parser\";\n// import * as path from \"path\";\n// import * as fs from \"fs-extra\";\nimport { RpcEntity, CMDOptions } from \"./interfaces\";\nimport { prettier } from \"../tools/format\";\n\n/* istanbul ignore next */\nexport async function print(\n  // export function print(\n  entity: RpcEntity | undefined\n  // options: CMDOptions,\n  // includeMap: { [key: string]: RpcEntity }\n): Promise<string> {\n  // ): string {\n  if (!entity || !entity.ns) {\n    // 过滤掉没有 namespace 的\n    return \"\";\n  }\n  // const ns = options.autoNamespace\n  //   ? printNamespace(entity, options.root)\n  //   : entity.ns;\n  const now = new Date();\n  const timeString = `${now.getFullYear()}-${\n    now.getMonth() + 1\n  }-${now.getDate()} ${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`;\n  const content = `// generate${` at ${timeString}`}\\n\n/**\n* @deprecated 强烈不建议使用i64类型，有些语言解析json里面 超过范围 [-(2^53)+1, (2^53)-1] 的数字会出现解析错误的情况，建议使用i32，如果可能超出i32的表示范围，建议使用string类型\n*/\ntype Int64 = string\\n\n${printConsts(entity)}\n${printEnums(entity)}\n${printInterfaces(entity)}\n${printTypeDefs(entity)}\n${printServices(entity)}\n`;\n\n  return content;\n  // const relativePath: path.ParsedPath = path.parse(\n  //   path.relative(options.root, entity.fileName)\n  // );\n  // const target = path.resolve(\n  //   options.tsRoot,\n  //   relativePath.dir,\n  //   `${relativePath.name}.ts`\n  // );\n\n  // await fs.ensureFile(target);\n  // return fs.writeFile(\n  //   target,\n  //   fixIncludeNamespace(content, entity, includeMap),\n  //   \"utf8\"\n  // );\n}\n\n/**\n * 根据到 root 的相对路径生成 namespace\n *\n * @param {RpcEntity} entity\n * @param {string} root\n * @returns {string} namespace\n */\n// function printNamespace(entity: RpcEntity, root: string): string {\n//   const relativePath: path.ParsedPath = path.parse(\n//     path.relative(root, entity.fileName)\n//   );\n//   const ns = relativePath.dir.replace(new RegExp(`\\\\${path.sep}`, \"g\"), \".\");\n//   /* istanbul ignore if */\n//   if (ns.indexOf(\".\") === 0) {\n//     throw new Error(\"ns error\");\n//   }\n\n//   return ns;\n// }\n\n/**\n * 输出 enums\n *\n * @export\n * @param {RpcEntity} entity thrift entity\n * @returns {string}\n */\nexport function printEnums(entity: RpcEntity): string {\n  /* istanbul ignore if */\n  if (!entity.enums || entity.enums.length === 0) {\n    return \"\";\n  }\n\n  let rtn: string = \"\";\n  entity.enums.forEach((datum, _i) => {\n    rtn += printComments(datum.commentsBefore);\n    rtn += `export const enum ${datum.name} {\n    ${Object.keys(datum.properties)\n      .map((key, i, arr) => {\n        const property = datum.properties[key];\n        const cb = printComments(property.commentsBefore); // comments before\n        const ca = printComments(property.commentsAfter, property.loc); // comments after\n        const temp = `${cb}${key} = ${property.value}${\n          arr.length - 1 === i ? \"\" : \",\"\n        }`;\n        return attachCommentAfterToAbovePosition(temp, ca);\n      })\n      .join(\"\\n    \")}\n}    ${printComments(datum.commentsAfter, datum.loc)}\n\n`;\n  });\n  return rtn;\n}\n\n/**\n * 输出 consts\n *\n * @export\n * @param {RpcEntity} entity thrift entity\n * @returns {string}\n */\nexport function printConsts(entity: RpcEntity): string {\n  /* istanbul ignore if */\n  if (!entity.consts || entity.consts.length === 0) {\n    return \"\";\n  }\n\n  let rtn: string = \"\";\n  entity.consts.forEach((datum, _i) => {\n    rtn += printComments(datum.commentsBefore);\n    if (\n      datum.type === SyntaxType.I64Keyword ||\n      datum.type === SyntaxType.StringKeyword\n    ) {\n      rtn += `export const ${datum.name} = '${datum.value}'\\n`;\n    } else {\n      rtn += `export const ${datum.name} = ${datum.value}\\n`;\n    }\n  });\n  return rtn;\n}\n\n/**\n * 输出 interfaces\n *\n * @export\n * @param {Pick<RpcEntity, 'interfaces'>} entity thrift entity\n * @returns {string}\n */\nexport function printInterfaces(\n  entity: Pick<RpcEntity, \"interfaces\">\n): Promise<string> | string {\n  if (!entity.interfaces || entity.interfaces.length === 0) {\n    return \"\";\n  }\n\n  let rtn = \"\";\n  entity.interfaces.forEach((datum, _i) => {\n    rtn += printComments(datum.commentsBefore);\n    rtn += `export interface ${datum.name} {\n    ${Object.keys(datum.properties)\n      .map((key, i, arr) => {\n        const property = datum.properties[key];\n        const cb = printComments(property.commentsBefore); // comments before\n        const ca = printComments(property.commentsAfter, property.loc); // comments after\n        let temp = `${key}${property.optional ? \"?\" : \"\"}: ${property.type};`;\n        if (ca) {\n          temp = attachCommentAfterToAbovePosition(temp, ca);\n        }\n        if (cb) {\n          temp = cb.trim() + \"\\n\" + temp.trim();\n        }\n        return temp;\n      })\n      .join(\"\\n    \")}\n}    ${printComments(datum.commentsAfter, datum.loc)}\n\n`;\n  });\n\n  // return prettier(rtn);\n  return rtn;\n}\n\n/**\n * 输出 typedef\n *\n * @export\n * @param {RpcEntity} entity\n * @returns {string}\n */\nexport function printTypeDefs(entity: RpcEntity): string {\n  if (entity.typeDefs.length === 0) {\n    return \"\";\n  }\n\n  let rtn = \"\";\n  entity.typeDefs.forEach((datum) => {\n    rtn += printComments(datum.commentsBefore);\n    rtn += `  export type ${datum.alias} = ${datum.type};${printComments(\n      datum.commentsAfter,\n      datum.loc\n    )}\\n`;\n  });\n  return rtn + \"\\n\";\n}\n\n/**\n * 以 12 个半角字符宽度对齐行注释\n *\n * @param {string} str\n * @param {string} comment\n * @returns {string}\n */\nfunction attachComment(str: string, comment: string): string {\n  const c = comment;\n\n  if (!c) {\n    return str;\n  }\n  const len = str.length + 1;\n  const len2 = Math.ceil(len / 12) * 12;\n  return `${str.padEnd(len2, \" \")} ${c}`;\n}\n\nfunction attachCommentAfterToAbovePosition(\n  str: string,\n  comment: string\n): string {\n  return comment.trim() + \"\\n    \" + str;\n}\n\n/**\n * 这个函数用来修复类型是通过 import 导入的名称\n *\n * @export\n * @param {string} content\n * @param {Pick<RpcEntity, 'fileName' | 'includes'>} entity\n * @param {{ [absolutFilepath: string]: RpcEntity }} includeMap\n * @returns {string}\n */\n// export function fixIncludeNamespace(\n//   content: string,\n//   entity: Partial<RpcEntity> & Pick<RpcEntity, \"fileName\" | \"includes\">,\n//   includeMap: {\n//     [absolutFilepath: string]: Partial<RpcEntity> & Pick<RpcEntity, \"ns\">;\n//   }\n// ): string {\n//   let result = content;\n//   const currentFile = path.parse(entity.fileName);\n//   entity.includes.forEach((include) => {\n//     // 获取所有 include 语句所对应的 entity\n//     const includeKey = path.resolve(currentFile.dir, include);\n//     const includeEntity = includeMap[includeKey];\n\n//     if (!includeEntity) {\n//       return;\n//     }\n\n//     const shouldBeNS = includeEntity.ns; // 需要替换成的 namespace\n//     const shouldReplaceNS = path.parse(include).name; // 如果文件中有用到 filename 作为 namespace\n\n//     result = result.replace(\n//       new RegExp(\n//         `([^\\\\w\\\\.])((?<!__SEGMENT__.*)${shouldReplaceNS}\\\\.|${shouldReplaceNS}(?!.*__SEGMENT__)\\\\.)`,\n//         \"g\"\n//       ),\n//       `__SEGMENT__$1${shouldBeNS}__SEGMENT__.`\n//     );\n//   });\n\n//   // return result.replace(new RegExp(`__SEGMENT__`, 'g'), '');\n//   return (\n//     \"// prettier-ignore\\n\" +\n//     prettier(result.replace(new RegExp(\"__SEGMENT__\", \"g\"), \"\"))\n//   );\n// }\n\n/**\n * 打印 service\n *\n * @export\n * @param {RpcEntity} entity\n * @param {boolean} [isGenerateRPC=false] 如果是用来生成 RPC 的打印，需要加上 namespace\n * @returns\n */\nexport function printServices(\n  entity: RpcEntity,\n  isGenerateRPC: boolean = false\n) {\n  const serviceEntity = entity.services;\n  const keyInNs = [\n    ...entity.enums.map((d) => d.name),\n    ...entity.typeDefs.map((d) => d.alias),\n    ...entity.interfaces.map((d) => d.name),\n  ];\n  return serviceEntity.reduce((rtn, cur) => {\n    rtn += printComments(cur.commentsBefore);\n    rtn += `export interface ${cur.name} {\n${Object.keys(cur.interfaces)\n  .map((key) => {\n    const i = cur.interfaces[key];\n    let sortTmp: any[] = [];\n    i.inputParams.forEach((d) => (sortTmp[d.index] = d));\n    sortTmp = sortTmp.filter((d) => !!d);\n    const inputParamsStr = (sortTmp as (typeof i)[\"inputParams\"])\n      .map((d) => {\n        const type =\n          isGenerateRPC && keyInNs.indexOf(d.type) !== -1\n            ? `${entity.ns}.${d.type}`\n            : d.type;\n        return `${d.name}: ${type}`;\n      })\n      .join(\", \");\n    const returnType =\n      isGenerateRPC && keyInNs.indexOf(i.returnType) !== -1\n        ? `${entity.ns}.${i.returnType}`\n        : i.returnType;\n    const cb = printComments(i.commentsBefore); // comments before\n    const ca = printComments(i.commentsAfter, i.loc); // comments after\n    let rtn = \"\";\n    if (cb.trim()) {\n      rtn += `    ${cb.trim()}\\n`;\n    }\n    if (ca.trim()) {\n      rtn += `    ${ca.trim()}\\n`;\n    }\n    rtn += `    ${key}(${inputParamsStr}): Promise<${returnType}>;`;\n    return rtn;\n  })\n  .join(\"\\n\")}\n}\n\n`;\n    return rtn;\n  }, \"\");\n}\n\n// export function printCollectionRpc(\n//   entity: RpcEntity,\n//   includeMap: {\n//     [absolutFilepath: string]: Partial<RpcEntity> & Pick<RpcEntity, \"ns\">;\n//   }\n// ): string | null {\n//   if (!entity.services.length) {\n//     return null;\n//   }\n//   const servicesCodes = printServices(entity, true);\n//   const rtn = fixIncludeNamespace(servicesCodes, entity, includeMap);\n//   return rtn;\n// }\n\nexport function printCommentLine(comment: CommentLine): string {\n  if (!comment.value) {\n    return \"\";\n  }\n  return `/** ${comment.value.replace(/\\*\\/+/g, \"\")} */`;\n}\n\nexport function printCommentBlock(comment: CommentBlock): string {\n  if (!comment.value.length) {\n    return \"\";\n  }\n  return `/*\\n* ${comment.value.join(\"\\n* \")}\\n*/`;\n}\n\n/**\n * @description 打印注释，如果是PrimarySyntax之前的注释，直接换行打印，如果是之后的注释\n *                传入PrimarySyntax的loc，判断是否打印在同一行\n *\n * @param comments 需要打印的comments\n * @param loc comments所属的PrimarySyntax的位置\n */\nexport function printComments(\n  comments: Comment[] = [],\n  loc?: TextLocation\n): string {\n  let res = \"\";\n  comments.forEach((comment, idx) => {\n    const sameLine =\n      loc &&\n      comment.loc.start.line === comment.loc.end.line &&\n      comment.loc.start.line === loc.end.line;\n    const lastOne = idx === comments.length - 1;\n    if (sameLine) {\n      if (comment.type === SyntaxType.CommentLine) {\n        res = printCommentLine(comment) + \"\\n\" + res;\n        if (!lastOne) {\n          res += \"    \";\n        }\n      }\n      if (comment.type === SyntaxType.CommentBlock) {\n        res += printCommentBlock(comment);\n        if (!lastOne) {\n          res += \"    \";\n        }\n      }\n    } else {\n      if (comment.type === SyntaxType.CommentLine) {\n        res = printCommentLine(comment) + \"\\n\" + res;\n        // 注释下面不要换行\n        // res += '\\n'\n      }\n      if (comment.type === SyntaxType.CommentBlock) {\n        res += printCommentBlock(comment);\n        // 注释下面不要换行\n        res += '\\n'\n      }\n    }\n  });\n  return res;\n}\n\n/**\n * @description 获取includeMap中的enum值\n */\nexport function printEnumsObject(includeMap: { [key: string]: RpcEntity }): {\n  [key: string]: number | string;\n} {\n  const res: { [key: string]: number | string } = {};\n  Object.keys(includeMap).forEach((key) => {\n    const rtn = includeMap[key];\n    if (rtn.ns) {\n      const namespace = rtn.ns;\n      const enums = rtn.enums;\n      // 在非--new的模式下，const为undefined\n      const consts = rtn.consts || [];\n      enums.forEach((e) => {\n        Object.keys(e.properties).forEach((eKey) => {\n          res[`${namespace}.${e.name}.${eKey}`] = e.properties[eKey].value;\n        });\n      });\n      consts.forEach((c) => {\n        let parsedValue: number | string;\n        if (\n          c.type === SyntaxType.ByteKeyword ||\n          c.type === SyntaxType.I8Keyword ||\n          c.type === SyntaxType.I16Keyword ||\n          c.type === SyntaxType.I32Keyword ||\n          c.type === SyntaxType.Int8Keyword ||\n          c.type === SyntaxType.Int16Keyword ||\n          c.type === SyntaxType.Int32Keyword\n        ) {\n          parsedValue = parseInt(c.value);\n        } else if (c.type === SyntaxType.DoubleKeyword) {\n          parsedValue = parseFloat(c.value);\n        } else {\n          parsedValue = c.value;\n        }\n        res[`${namespace}.${c.name}`] = parsedValue;\n      });\n    }\n  });\n  const sortedRes = Object.keys(res)\n    .sort()\n    .reduce(\n      (pre, cur) => {\n        pre[cur] = res[cur];\n        return pre;\n      },\n      {} as typeof res\n    );\n  return sortedRes;\n}\n","import React, { useState } from \"react\";\nimport { Controlled as CodeMirror, UnControlled as CodeMirror2 } from \"react-codemirror2\";\nimport \"codemirror/lib/codemirror.css\";\nimport \"codemirror/theme/dracula.css\"; // 使用 Dracula 主题\nimport \"codemirror/mode/javascript/javascript\"; // 引入 JavaScript 语法高亮\nimport { parser } from \"@/lib/thriftNew\";\nimport { print } from \"@/lib/thriftNew/print\";\nimport { prettier } from \"@/lib/tools/format\";\nimport './globals.css'\n\nconst START_THRIFT = `namespace java com.example.thrift\nnamespace py example.thrift\n\nconst string test = 'test'\n\n// 定义一个枚举类型，表示用户的状态\nenum UserStatus {\n    ACTIVE = 0,  // 用户活跃\n    INACTIVE = 1,  // 用户不活跃\n    SUSPENDED = 2,  // 用户被暂停\n    DELETED = 3  // 用户已删除\n}\n\n// 定义一个枚举类型，表示订单的状态\nenum OrderStatus {\n    PENDING = 0,  // 待处理\n    SHIPPED = 1,  // 已发货\n    DELIVERED = 2,  // 已送达\n    CANCELED = 3  // 已取消\n}\n\n// 定义一个复杂数据结构 - 用户\nstruct User {\n    1: required i32 user_id;  // 必选的用户ID\n    2: required string name;  // 必选的用户名\n    3: optional string email;  // 可选的电子邮件\n    4: required UserStatus status;  // 必选的用户状态\n    5: optional string phone_number;  // 可选的电话号码\n    6: required i64 created_at;  // 必选的创建时间\n    7: optional i64 last_login;  // 可选的最后登录时间\n    8: optional map<string, string> preferences;  // 可选的用户偏好设置\n    9: optional list<i32> friend_ids;  // 可选的朋友ID列表\n}\n\n// 定义一个复杂数据结构 - 地址\nstruct Address {\n    1: required string street;  // 必选的街道\n    2: required string city;  // 必选的城市\n    3: required string state;  // 必选的州\n    4: required string country;  // 必选的国家\n    5: required string zip_code;  // 必选的邮政编码\n    6: optional string phone_number;  // 可选的地址关联电话号码\n}\n\n// 定义一个复杂数据结构 - 订单\nstruct Order {\n    1: required i32 order_id;  // 必选的订单ID\n    2: required i32 user_id;  // 必选的用户ID（订单关联的用户）\n    3: required list<i32> product_ids;  // 必选的产品ID列表\n    4: required double total_amount;  // 必选的订单总金额\n    5: required OrderStatus status;  // 必选的订单状态\n    6: required i64 created_at;  // 必选的创建时间\n    7: optional string shipping_address;  // 可选的配送地址\n    8: optional Address billing_address;  // 可选的账单地址\n    9: optional i64 shipping_time;  // 可选的发货时间\n    10: optional list<string> order_notes;  // 可选的订单备注\n    11: optional map<string, string> order_metadata;  // 可选的订单元数据\n}\n\n// 定义一个复杂的数据结构 - 商品\nstruct Product {\n    1: required i32 product_id;  // 必选的商品ID\n    2: required string name;  // 必选的商品名称\n    3: required double price;  // 必选的商品价格\n    4: required string description;  // 必选的商品描述\n    5: optional string image_url;  // 可选的商品图片URL\n    6: optional bool in_stock;  // 可选的库存状态\n}\n\n// 定义一个复杂的数据结构 - 购物车\nstruct Cart {\n    1: required i32 cart_id;  // 必选的购物车ID\n    2: required i32 user_id;  // 必选的用户ID\n    3: required list<Product> products;  // 必选的商品列表\n    4: required double total_price;  // 必选的购物车总价格\n    5: optional i64 created_at;  // 可选的购物车创建时间\n    6: optional bool is_active;  // 可选的购物车是否有效\n}\n\n// 定义一个复杂的数据结构 - 支付信息\nstruct PaymentInfo {\n    1: required string payment_method;  // 必选的支付方式\n    2: required double amount;  // 必选的支付金额\n    3: required i64 payment_time;  // 必选的支付时间\n    4: optional string transaction_id;  // 可选的交易ID\n    5: optional string payment_status;  // 可选的支付状态\n}\n\n// 定义一个包含多个复杂结构的复杂数据结构\nstruct UserProfile {\n    1: required i32 user_id;  // 必选的用户ID\n    2: required string username;  // 必选的用户名\n    3: optional string avatar_url;  // 可选的头像URL\n    4: required string bio;  // 必选的个人简介\n    5: optional list<Address> addresses;  // 可选的地址列表\n    6: required list<Order> orders;  // 必选的订单列表\n    7: optional Cart cart;  // 可选的购物车\n    8: optional list<PaymentInfo> payment_history;  // 可选的支付历史\n}\n\nstruct MyStruct {\n\t1: optional string test\n}\n\nservice MyService {\n\tvoid ping()\n}\n\n// 服务接口，定义用户相关操作\nservice UserService {\n    // 创建新用户\n    void createUser(1: required string name, 2: required string email);\n\n    // 获取用户资料\n    UserProfile getUserProfile(1: required i32 user_id);\n\n    // 更新用户资料\n    void updateUserProfile(1: required i32 user_id, 2: required UserProfile user_profile);\n\n    // 获取用户的所有订单\n    list<Order> getUserOrders(1: required i32 user_id);\n\n    // 创建一个新的订单\n    void createOrder(1: required i32 user_id, 2: required list<i32> product_ids, 3: required double total_amount);\n\n    // 获取订单详情\n    Order getOrderDetails(1: required i32 order_id);\n}\n\n// 服务接口，定义订单相关操作\nservice OrderService {\n    // 创建新订单\n    void createOrder(1: required i32 user_id, 2: required list<i32> product_ids, 3: required double total_amount);\n\n    // 获取订单信息\n    Order getOrder(1: required i32 order_id);\n\n    // 更新订单状态\n    void updateOrderStatus(1: required i32 order_id, 2: required OrderStatus status);\n}\n\n// 服务接口，定义商品相关操作\nservice ProductService {\n    // 获取商品列表\n    list<Product> getProducts(1: required i32 page, 2: required i32 page_size);\n\n    // 获取单个商品详情\n    Product getProductDetails(1: required i32 product_id);\n}\n`\n\nexport default function Home() {\n  const [thrift, setThrift] = useState(START_THRIFT);\n\n  const [tsCode, setTsCode] = useState(\"\");\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const handleChange = (editor: any, data: any, value: any) => {\n    setThrift(value);\n  };\n\n  const handleClick = async () => {\n    const ast = parser(\"\", thrift);\n    const tsCode = await print(ast);\n    // const result = await prettier(tsCode);\n    setTsCode(tsCode);\n  };\n  return (\n    <div className=\"App flex px-[15px] py-[15px] flex-col\">\n      <h1 className=\"text-[24px] font-600 mb-[10px]\">Thrift 转换 Typescript</h1>\n\n      <div className=\"flex\">\n        <CodeMirror\n          value={thrift}\n          options={{\n            mode: \"javascript\", // 设置编辑器模式为 JavaScript\n            theme: \"dracula\", // 使用 Dracula 主题\n            lineNumbers: true, // 显示行号\n            indentUnit: 2, // 设置缩进空格为 2\n            tabSize: 2, // 设置 Tab 大小为 2\n            autoCloseBrackets: true, // 自动闭合括号\n            matchBrackets: true, // 匹配括号\n            showCursorWhenSelecting: true, // 选中时显示光标\n          }}\n          onBeforeChange={handleChange} // 每次编辑内容变化时更新 state\n        />\n        <div className=\"mx-[10px] flex\">\n          <button\n            className=\"h-[30px] w-[50px] rounded-[10%] border border-solid m-auto cursor-pointer\"\n            onClick={handleClick}\n          >\n            转换\n          </button>\n        </div>\n\n        <CodeMirror2\n          value={tsCode}\n          options={{\n            mode: \"javascript\", // 设置编辑器模式为 JavaScript\n            theme: \"dracula\", // 使用 Dracula 主题\n            lineNumbers: true, // 显示行号\n            indentUnit: 2, // 设置缩进空格为 2\n            tabSize: 2, // 设置 Tab 大小为 2\n            autoCloseBrackets: true, // 自动闭合括号\n            matchBrackets: true, // 匹配括号\n            showCursorWhenSelecting: true, // 选中时显示光标\n            readOnly: true,\n          }}\n        />\n\n        {/* <button onClick={() => alert(code)}>查看代码</button> */}\n      </div>\n    </div>\n  );\n}\n","import {\n    ConstDefinition,\n    EnumDefinition,\n    ExceptionDefinition,\n    IncludeDefinition,\n    NamespaceDefinition,\n    ServiceDefinition,\n    StructDefinition,\n    SyntaxType,\n    ThriftDocument,\n    TypedefDefinition,\n    UnionDefinition,\n} from './types'\n\nexport function organize(raw: ThriftDocument): ThriftDocument {\n    const namespaces: Array<NamespaceDefinition> = []\n    const includes: Array<IncludeDefinition> = []\n    const constants: Array<ConstDefinition> = []\n    const enums: Array<EnumDefinition> = []\n    const typedefs: Array<TypedefDefinition> = []\n    const structs: Array<StructDefinition> = []\n    const unions: Array<UnionDefinition> = []\n    const exceptions: Array<ExceptionDefinition> = []\n    const services: Array<ServiceDefinition> = []\n\n    for (const next of raw.body) {\n        switch (next.type) {\n            case SyntaxType.NamespaceDefinition:\n                namespaces.push(next)\n                break\n\n            case SyntaxType.IncludeDefinition:\n                includes.push(next)\n                break\n\n            case SyntaxType.CppIncludeDefinition:\n                // We're not generating C++\n                break\n\n            case SyntaxType.ConstDefinition:\n                constants.push(next)\n                break\n\n            case SyntaxType.EnumDefinition:\n                enums.push(next)\n                break\n\n            case SyntaxType.StructDefinition:\n                structs.push(next)\n                break\n\n            case SyntaxType.UnionDefinition:\n                unions.push(next)\n                break\n\n            case SyntaxType.ExceptionDefinition:\n                exceptions.push(next)\n                break\n\n            case SyntaxType.TypedefDefinition:\n                typedefs.push(next)\n                break\n\n            case SyntaxType.ServiceDefinition:\n                services.push(next)\n                break\n\n            default:\n                const msg: never = next\n                throw new Error(`Unexpected statement type found: ${msg}`)\n        }\n    }\n\n    return {\n        type: SyntaxType.ThriftDocument,\n        body: [\n            ...namespaces,\n            ...includes,\n            ...enums,\n            ...typedefs,\n            ...constants,\n            ...structs,\n            ...unions,\n            ...exceptions,\n            ...services,\n        ],\n        tokens: raw.tokens,\n    }\n}\n"],"names":["ErrorType","SyntaxType","noopReporter","err","Error","createTextLocation","start","end","createIdentifier","value","loc","annotations","createStringLiteral","createIntConstant","createDoubleConstant","createBooleanLiteral","KEYWORDS","RESERVEDWORDS","isStatementBeginning","token","ParseError","msg","isDigit","isAlphaOrUnderscore","isAlpha","isValidIdentifier","ScanError","defaultOptions","collectCommentsAndPrimarySyntax","ast","comments","primarySyntaxNodes","primarySyntaxType","hasChildrenType","collectSingleComments","item","thriftStatement","type","a","b","handleComments","node","commemt","targetNode","i","commentEndIndex","pNode","nodeStartIndex","error","chalk","getFieldTypeString","fieldType","_field_name","options","field","i64Type","mapType","ThriftType2JavascriptType","console","handleField","defaultValue","structName","name","commentsBefore","index","String","tagNameReg","nameTag","annotation","match","tagValueReg","fieldComment","fieldKey","Array","comment","fieldKeyArr","optional","isRes","isReq","useStrict","useStrictReq","hasDefault","_print","entity","now","Date","timeString","printConsts","printEnums","rtn","datum","_i","printComments","printInterfaces","Object","key","arr","property","cb","ca","attachCommentAfterToAbovePosition","printTypeDefs","temp","printServices","isGenerateRPC","serviceEntity","keyInNs","d","cur","sortTmp","inputParamsStr","returnType","_$rtn","str","printCommentLine","printCommentBlock","res","idx","sameLine","lastOne","Home","thrift","setThrift","useState","tsCode","setTsCode","handleClick","parser","filefullname","source","includeMap","parse","sourceLines","formattedErrors","rawErrors","mergedOptions","debug","formattedError","lineNumber","padLeft","num","prefix","errorType","padStart","length","paddedStr","scanner","createScanner","src","report","tokens","line","column","startLine","startColumn","startIndex","currentIndex","number","current","consume","hexadecimal","isAtEnd","peek","advance","commitToken","integer","enotation","peekNext","reportError","singleLineComment","addToken","text","nextLine","currentLocation","scan","scanToken","next","string","terminator","previous","literal","multilineComment","cursor","identifier","e","message","syncronize","isWhiteSpace","char","handleError","createParser","parseParameterFields","fields","openParen","requireValue","check","readListSeparator","parseField","currentToken","closeParen","parseValueAssignment","parseValue","parseIntValue","parseDoubleValue","parseMapValue","properties","startLoc","readMapValues","initializer","endLoc","closeBrace","location","parseListValue","elements","readListValues","parseAnnotations","startToken","parseAnnotation","valueToken","nameToken","undefined","endToken","parseStructLikeInterface","leadingComments","getComments","keywordToken","parseFields","fieldID","parseFieldId","fieldIDToken","colonToken","parseInt","fieldRequired","parseFieldType","IdentifierRegExp","listSeparator","openBracket","valueType","closeBracket","typeToken","escapeReservedWordForIdentifier","parseMapType","keyType","ReservedWordsForIdentifierRegExp","RegExp","v","replaceCount","replacedText","originText","consumeComments","_key","types","previousToken","val","statement","parseStatement","parseNamespace","scopeToken","_nameToken","nameTokenText","parseInclude","pathToken","parseConst","parseStruct","parsedData","parseUnion","parseException","parseService","extendsId","parseExtends","checkText","strs","functions","parseFunctions","parseFunction","onewayToken","parseFunctionType","params","throws","parseThrows","parseTypedef","parseEnum","members","parseEnumMembers","parseEnumMember","synchronize","intermediate","organize","raw","namespaces","includes","constants","enums","typedefs","structs","unions","exceptions","services","alert","ts","currentValue","aInterface","aTypeDef","aService","func","handleFunction","inputParams","functionMethod","functionUri","member","handleConst","c","cType","constType","typeString","namespacesValues","print","CodeMirror","editor","data","CodeMirror2"],"mappings":"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"}